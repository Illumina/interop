<!-- HTML header for doxygen 1.8.8-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
 <meta http-equiv="X-UA-Compatible" content="IE=edge">
 <!-- For Mobile Devices -->
 <meta name="viewport" content="width=device-width, initial-scale=1">
 <!-- Loading Lato Font -->
 <link href='https://fonts.googleapis.com/css?family=Lato:300,400,700,300italic,400italic,700italic' rel='stylesheet' type='text/css'>
 <!-- Loading Font Awesome -->
 <link rel="stylesheet" href="https://maxcdn.bootstrapcdn.com/font-awesome/4.3.0/css/font-awesome.min.css">
 <meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
 <meta name="generator" content="Doxygen 1.8.10"/>
 <script type="text/javascript" src="https://code.jquery.com/jquery-2.1.1.min.js"></script>
 <script>
  (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
  (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
  m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
  })(window,document,'script','https://www.google-analytics.com/analytics.js','ga');
  ga('create', 'UA-88338608-1', 'auto');
  ga('send', 'pageview');
</script>
 <title>illumina::interop::util Namespace Reference</title>
 <!--<link href="tabs.css" rel="stylesheet" type="text/css"/>-->
 <script type="text/javascript" src="dynsections.js"></script>
 <link href="doxygen.css" rel="stylesheet" type="text/css" />
 <link href="customdoxygen.css" rel="stylesheet" type="text/css" />
 <link rel="stylesheet" href="bootstrap3/css/bootstrap.min.css">
 <link href="bootstrap3/css/sticky-footer-navbar.css" rel="stylesheet">
 <script src="bootstrap3/js/bootstrap.min.js"></script>
 <script type="text/javascript" src="doxy-boot.js"></script>
</head>
<body screen_capture_injected="true">
<nav class="navbar navbar-inverse" role="navigation">
 <div class="container">
  <div class="navbar-header">
   <a class="navbar-brand" href="https://www.illumina.com/"><img style='margin-top: -8px !important;height: 40px !important;' src='ILLUMINA_LOGO_RGB_new_200_45.png' /></a>
   <a class="navbar-brand">InterOp <span style="font-size: 10pt">v1.1.27</span>  </a>
  </div>
  <div class="collapse navbar-collapse">
   <!-- Left -->
   <ul class="nav navbar-nav adjust-right">
    <li><a href="https://github.com/Illumina/interop">Code</a></li>
    <li><a href="https://github.com/Illumina/interop/issues">Issues</a></li>
    <li><a href="https://github.com/Illumina/interop/releases/latest">Download</a></li>
   </ul>
  </div><!--/.nav-collapse -->
 </div>
</nav>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
 <div class="content" id="content">
  <div class="container">
   <div class="row">
    <div class="col-sm-12 panel panel-default" style="padding-bottom: 15px;">
     <div style="margin-bottom: 15px;">
      <!-- end header part -->
<!-- Generated by Doxygen 1.8.10 -->
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Home</span></a></li>
      <li><a href="pages.html"><span>Index</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="namespacemembers.html"><span>Namespace&#160;Members</span></a></li>
    </ul>
  </div>
<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespaceillumina.html">illumina</a></li><li class="navelem"><a class="el" href="namespaceillumina_1_1interop.html">interop</a></li><li class="navelem"><a class="el" href="namespaceillumina_1_1interop_1_1util.html">util</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#namespaces">Namespaces</a> &#124;
<a href="#nested-classes">Classes</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">illumina::interop::util Namespace Reference</div>  </div>
</div><!--header-->
<div class="contents">
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="namespaces"></a>
Namespaces</h2></td></tr>
<tr class="memitem:namespaceillumina_1_1interop_1_1util_1_1detail"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceillumina_1_1interop_1_1util_1_1detail.html">detail</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespaceillumina_1_1interop_1_1util_1_1op"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceillumina_1_1interop_1_1util_1_1op.html">op</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classillumina_1_1interop_1_1util_1_1abstract__option.html">abstract_option</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classillumina_1_1interop_1_1util_1_1abstract__range__iterator.html">abstract_range_iterator</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structillumina_1_1interop_1_1util_1_1base__exception.html">base_exception</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classillumina_1_1interop_1_1util_1_1chain__range__iterator.html">chain_range_iterator</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classillumina_1_1interop_1_1util_1_1constant__mapping.html">constant_mapping</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structillumina_1_1interop_1_1util_1_1csharp__date__time.html">csharp_date_time</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classillumina_1_1interop_1_1util_1_1indirect__range__iterator.html">indirect_range_iterator</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classillumina_1_1interop_1_1util_1_1invalid__option__exception.html">invalid_option_exception</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classillumina_1_1interop_1_1util_1_1invalid__option__value__exception.html">invalid_option_value_exception</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structillumina_1_1interop_1_1util_1_1length__of__type.html">length_of_type</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structillumina_1_1interop_1_1util_1_1length__of__type_3_01std_1_1vector_3_01_t_01_4_01_4.html">length_of_type&lt; std::vector&lt; T &gt; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structillumina_1_1interop_1_1util_1_1lexical__cast__helper.html">lexical_cast_helper</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structillumina_1_1interop_1_1util_1_1lexical__cast__helper_3_01char_01_5_00_01_destination_01_4.html">lexical_cast_helper&lt; char *, Destination &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structillumina_1_1interop_1_1util_1_1lexical__cast__helper_3_01char_01_5_00_01std_1_1string_01_4.html">lexical_cast_helper&lt; char *, std::string &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structillumina_1_1interop_1_1util_1_1lexical__cast__helper_3_01const_01char_01_5_00_01_destination_01_4.html">lexical_cast_helper&lt; const char *, Destination &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structillumina_1_1interop_1_1util_1_1lexical__cast__helper_3_01const_01char_01_5_00_01std_1_1string_01_4.html">lexical_cast_helper&lt; const char *, std::string &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structillumina_1_1interop_1_1util_1_1lexical__cast__helper_3_01const_01_source_01_6_00_01std_1_1string_01_4.html">lexical_cast_helper&lt; const Source &amp;, std::string &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structillumina_1_1interop_1_1util_1_1lexical__cast__helper_3_01_source_00_01std_1_1string_01_4.html">lexical_cast_helper&lt; Source, std::string &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structillumina_1_1interop_1_1util_1_1lexical__cast__helper_3_01std_1_1string_00_01const_01char_01_5_01_4.html">lexical_cast_helper&lt; std::string, const char * &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structillumina_1_1interop_1_1util_1_1lexical__cast__helper_3_01std_1_1string_00_01_destination_01_4.html">lexical_cast_helper&lt; std::string, Destination &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structillumina_1_1interop_1_1util_1_1lexical__cast__helper_3_01std_1_1string_00_01std_1_1string_01_4.html">lexical_cast_helper&lt; std::string, std::string &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classillumina_1_1interop_1_1util_1_1option.html">option</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classillumina_1_1interop_1_1util_1_1option__exception.html">option_exception</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classillumina_1_1interop_1_1util_1_1option__parser.html">option_parser</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classillumina_1_1interop_1_1util_1_1scoped__timer.html">scoped_timer</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structillumina_1_1interop_1_1util_1_1_string_case_insensitive_comparator.html">StringCaseInsensitiveComparator</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classillumina_1_1interop_1_1util_1_1value__container.html">value_container</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classillumina_1_1interop_1_1util_1_1value__container_3_01_r_07_t_1_1_5_08_07_p1_08_01_4.html">value_container&lt; R(T::*)(P1) &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:afdcbece3327f898cdc9516ebcc075afb"><td class="memTemplParams" colspan="2">template&lt;class Key , class Value , size_t N&gt; </td></tr>
<tr class="memitem:afdcbece3327f898cdc9516ebcc075afb"><td class="memTemplItemLeft" align="right" valign="top">const Value &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceillumina_1_1interop_1_1util.html#afdcbece3327f898cdc9516ebcc075afb">constant_mapping_get</a> (const std::pair&lt; Key, Value &gt;(&amp;pairs)[N], const Key &amp;key, const Value &amp;default_value)</td></tr>
<tr class="separator:afdcbece3327f898cdc9516ebcc075afb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aba0e191a6382d97a3931c087e05d2907"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:aba0e191a6382d97a3931c087e05d2907"><td class="memTemplItemLeft" align="right" valign="top">size_t&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceillumina_1_1interop_1_1util.html#aba0e191a6382d97a3931c087e05d2907">length_of</a> (const T &amp;val)</td></tr>
<tr class="separator:aba0e191a6382d97a3931c087e05d2907"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9eb3978dbfbd02949f5ccdfe663ed4d4"><td class="memTemplParams" colspan="2">template&lt;typename T , size_t N&gt; </td></tr>
<tr class="memitem:a9eb3978dbfbd02949f5ccdfe663ed4d4"><td class="memTemplItemLeft" align="right" valign="top">size_t&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceillumina_1_1interop_1_1util.html#a9eb3978dbfbd02949f5ccdfe663ed4d4">length_of</a> (const T(&amp;)[N])</td></tr>
<tr class="separator:a9eb3978dbfbd02949f5ccdfe663ed4d4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4ad6e9ed14d61c6379784ac331ceb6c2"><td class="memTemplParams" colspan="2">template&lt;class Destination , class Source &gt; </td></tr>
<tr class="memitem:a4ad6e9ed14d61c6379784ac331ceb6c2"><td class="memTemplItemLeft" align="right" valign="top">Destination&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceillumina_1_1interop_1_1util.html#a4ad6e9ed14d61c6379784ac331ceb6c2">lexical_cast</a> (const Source &amp;src)</td></tr>
<tr class="separator:a4ad6e9ed14d61c6379784ac331ceb6c2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af7e80564fd7e8e5fbff5dde1d6b9ad41"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceillumina_1_1interop_1_1util.html#af7e80564fd7e8e5fbff5dde1d6b9ad41">format</a> (const float val, const int width, const int precision, const char fill= ' ', const bool fixed=true)</td></tr>
<tr class="separator:af7e80564fd7e8e5fbff5dde1d6b9ad41"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a31e479779f58a3fd59052c18abf63ebc"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a31e479779f58a3fd59052c18abf63ebc"><td class="memTemplItemLeft" align="right" valign="top">float&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceillumina_1_1interop_1_1util.html#a31e479779f58a3fd59052c18abf63ebc">float_cast</a> (const T val, const T sentinel=std::numeric_limits&lt; T &gt;::max())</td></tr>
<tr class="separator:a31e479779f58a3fd59052c18abf63ebc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a85663336098d396b34a87db5a66b37d7"><td class="memTemplParams" colspan="2">template&lt;typename T , typename R , typename P1 &gt; </td></tr>
<tr class="memitem:a85663336098d396b34a87db5a66b37d7"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classillumina_1_1interop_1_1util_1_1value__container.html">value_container</a>&lt; R(T::*)(P1) &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceillumina_1_1interop_1_1util.html#a85663336098d396b34a87db5a66b37d7">wrap_setter</a> (T &amp;obj, R(T::*func)(P1))</td></tr>
<tr class="separator:a85663336098d396b34a87db5a66b37d7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa3fb290d02820e5caa24b9275993c3bc"><td class="memTemplParams" colspan="2">template&lt;typename I , typename O , typename F &gt; </td></tr>
<tr class="memitem:aa3fb290d02820e5caa24b9275993c3bc"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceillumina_1_1interop_1_1util.html#aa3fb290d02820e5caa24b9275993c3bc">outliers_lower</a> (I beg, I end, const F bound, O out)</td></tr>
<tr class="separator:aa3fb290d02820e5caa24b9275993c3bc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8be6288c1dc05281975e45f8463215a1"><td class="memTemplParams" colspan="2">template&lt;typename I , typename O , typename F &gt; </td></tr>
<tr class="memitem:a8be6288c1dc05281975e45f8463215a1"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceillumina_1_1interop_1_1util.html#a8be6288c1dc05281975e45f8463215a1">outliers_upper</a> (I beg, I end, const F bound, O out)</td></tr>
<tr class="separator:a8be6288c1dc05281975e45f8463215a1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a54a97a439caba7e4866575703cbcc404"><td class="memTemplParams" colspan="2">template&lt;typename I &gt; </td></tr>
<tr class="memitem:a54a97a439caba7e4866575703cbcc404"><td class="memTemplItemLeft" align="right" valign="top">I&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceillumina_1_1interop_1_1util.html#a54a97a439caba7e4866575703cbcc404">percentile</a> (I beg, I end, const size_t percentile)</td></tr>
<tr class="separator:a54a97a439caba7e4866575703cbcc404"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac594a00c4497eed8de9baad5f52d6fa9"><td class="memTemplParams" colspan="2">template&lt;typename I , typename Compare &gt; </td></tr>
<tr class="memitem:ac594a00c4497eed8de9baad5f52d6fa9"><td class="memTemplItemLeft" align="right" valign="top">I&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceillumina_1_1interop_1_1util.html#ac594a00c4497eed8de9baad5f52d6fa9">percentile</a> (I beg, I end, const size_t percentile, Compare comp)</td></tr>
<tr class="separator:ac594a00c4497eed8de9baad5f52d6fa9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9fe29328dd1979e022b48a3c4cfe1b1b"><td class="memTemplParams" colspan="2">template&lt;typename F &gt; </td></tr>
<tr class="memitem:a9fe29328dd1979e022b48a3c4cfe1b1b"><td class="memTemplItemLeft" align="right" valign="top">F&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceillumina_1_1interop_1_1util.html#a9fe29328dd1979e022b48a3c4cfe1b1b">interpolate_linear</a> (const F y1, const F y2, const F x1, const F x2, const F xt)</td></tr>
<tr class="separator:a9fe29328dd1979e022b48a3c4cfe1b1b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0dcdea84d6f1c1d93a0b0cb16920daf0"><td class="memTemplParams" colspan="2">template&lt;typename F , typename I &gt; </td></tr>
<tr class="memitem:a0dcdea84d6f1c1d93a0b0cb16920daf0"><td class="memTemplItemLeft" align="right" valign="top">F&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceillumina_1_1interop_1_1util.html#a0dcdea84d6f1c1d93a0b0cb16920daf0">percentile_sorted</a> (I beg, I end, const size_t <a class="el" href="namespaceillumina_1_1interop_1_1util.html#a54a97a439caba7e4866575703cbcc404">percentile</a>)</td></tr>
<tr class="separator:a0dcdea84d6f1c1d93a0b0cb16920daf0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abaf3af7779b9d340cba9d51c138e264e"><td class="memTemplParams" colspan="2">template&lt;typename F , typename I , typename Op &gt; </td></tr>
<tr class="memitem:abaf3af7779b9d340cba9d51c138e264e"><td class="memTemplItemLeft" align="right" valign="top">F&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceillumina_1_1interop_1_1util.html#abaf3af7779b9d340cba9d51c138e264e">percentile_sorted</a> (I beg, I end, const size_t <a class="el" href="namespaceillumina_1_1interop_1_1util.html#a54a97a439caba7e4866575703cbcc404">percentile</a>, Op op)</td></tr>
<tr class="separator:abaf3af7779b9d340cba9d51c138e264e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a26c663639533827578ff07630ca16784"><td class="memTemplParams" colspan="2">template&lt;typename I , typename UnaryOp &gt; </td></tr>
<tr class="memitem:a26c663639533827578ff07630ca16784"><td class="memTemplItemLeft" align="right" valign="top">I&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceillumina_1_1interop_1_1util.html#a26c663639533827578ff07630ca16784">remove_nan</a> (I beg, I end, UnaryOp op)</td></tr>
<tr class="separator:a26c663639533827578ff07630ca16784"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a013f14849308448e6b3f3aff315a7a4e"><td class="memTemplParams" colspan="2">template&lt;typename I &gt; </td></tr>
<tr class="memitem:a013f14849308448e6b3f3aff315a7a4e"><td class="memTemplItemLeft" align="right" valign="top">I&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceillumina_1_1interop_1_1util.html#a013f14849308448e6b3f3aff315a7a4e">median</a> (I beg, I end)</td></tr>
<tr class="separator:a013f14849308448e6b3f3aff315a7a4e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1c0316a0e324ee511e7ede2110ef156f"><td class="memTemplParams" colspan="2">template&lt;typename I , typename Compare &gt; </td></tr>
<tr class="memitem:a1c0316a0e324ee511e7ede2110ef156f"><td class="memTemplItemLeft" align="right" valign="top">I&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceillumina_1_1interop_1_1util.html#a1c0316a0e324ee511e7ede2110ef156f">median</a> (I beg, I end, Compare comp)</td></tr>
<tr class="separator:a1c0316a0e324ee511e7ede2110ef156f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7a541cc6fe2b6d9eb48ec5970b709a13"><td class="memTemplParams" colspan="2">template&lt;typename F , typename I &gt; </td></tr>
<tr class="memitem:a7a541cc6fe2b6d9eb48ec5970b709a13"><td class="memTemplItemLeft" align="right" valign="top">F&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceillumina_1_1interop_1_1util.html#a7a541cc6fe2b6d9eb48ec5970b709a13">median_interpolated</a> (I beg, I end)</td></tr>
<tr class="separator:a7a541cc6fe2b6d9eb48ec5970b709a13"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0733552eca182f2d917c02523020c81a"><td class="memTemplParams" colspan="2">template&lt;typename F , typename I , typename Compare &gt; </td></tr>
<tr class="memitem:a0733552eca182f2d917c02523020c81a"><td class="memTemplItemLeft" align="right" valign="top">F&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceillumina_1_1interop_1_1util.html#a0733552eca182f2d917c02523020c81a">median_interpolated</a> (I beg, I end, Compare comp)</td></tr>
<tr class="separator:a0733552eca182f2d917c02523020c81a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0838a1b75c4b3bd2fc9fd67b7dcaed53"><td class="memTemplParams" colspan="2">template&lt;typename F , typename I , typename Compare , typename Op &gt; </td></tr>
<tr class="memitem:a0838a1b75c4b3bd2fc9fd67b7dcaed53"><td class="memTemplItemLeft" align="right" valign="top">F&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceillumina_1_1interop_1_1util.html#a0838a1b75c4b3bd2fc9fd67b7dcaed53">median_interpolated</a> (I beg, I end, Compare comp, Op op)</td></tr>
<tr class="separator:a0838a1b75c4b3bd2fc9fd67b7dcaed53"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8a4ef71819a384de1855c3a550c1ad5b"><td class="memTemplParams" colspan="2">template&lt;typename R , typename I , typename BinaryOp &gt; </td></tr>
<tr class="memitem:a8a4ef71819a384de1855c3a550c1ad5b"><td class="memTemplItemLeft" align="right" valign="top">R&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceillumina_1_1interop_1_1util.html#a8a4ef71819a384de1855c3a550c1ad5b">nan_mean</a> (I beg, I end, BinaryOp op)</td></tr>
<tr class="separator:a8a4ef71819a384de1855c3a550c1ad5b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aad6d0943990f6a951872fca1717bdc84"><td class="memTemplParams" colspan="2">template&lt;typename R , typename I , typename BinaryOp &gt; </td></tr>
<tr class="memitem:aad6d0943990f6a951872fca1717bdc84"><td class="memTemplItemLeft" align="right" valign="top">R&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceillumina_1_1interop_1_1util.html#aad6d0943990f6a951872fca1717bdc84">nan_variance_with_mean</a> (I beg, I end, const R mean_val, BinaryOp op)</td></tr>
<tr class="separator:aad6d0943990f6a951872fca1717bdc84"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6bd55e46e90bd70a8a5bac9e100d9569"><td class="memTemplParams" colspan="2">template&lt;typename R , typename I , typename BinaryOp &gt; </td></tr>
<tr class="memitem:a6bd55e46e90bd70a8a5bac9e100d9569"><td class="memTemplItemLeft" align="right" valign="top">R&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceillumina_1_1interop_1_1util.html#a6bd55e46e90bd70a8a5bac9e100d9569">nan_variance</a> (I beg, I end, BinaryOp op)</td></tr>
<tr class="separator:a6bd55e46e90bd70a8a5bac9e100d9569"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2031849375ca583266a2b24181c9e2be"><td class="memTemplParams" colspan="2">template&lt;typename R , typename I , typename BinaryOp &gt; </td></tr>
<tr class="memitem:a2031849375ca583266a2b24181c9e2be"><td class="memTemplItemLeft" align="right" valign="top">R&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceillumina_1_1interop_1_1util.html#a2031849375ca583266a2b24181c9e2be">mean</a> (I beg, I end, BinaryOp op)</td></tr>
<tr class="separator:a2031849375ca583266a2b24181c9e2be"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac6e881e574ffb6b541620d93492b5169"><td class="memTemplParams" colspan="2">template&lt;typename R , typename I , typename BinaryOp &gt; </td></tr>
<tr class="memitem:ac6e881e574ffb6b541620d93492b5169"><td class="memTemplItemLeft" align="right" valign="top">R&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceillumina_1_1interop_1_1util.html#ac6e881e574ffb6b541620d93492b5169">variance_with_mean</a> (I beg, I end, const R mean_val, BinaryOp op)</td></tr>
<tr class="separator:ac6e881e574ffb6b541620d93492b5169"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1f71883e0a08588f121d7ab696a42cbd"><td class="memTemplParams" colspan="2">template&lt;typename R , typename I , typename BinaryOp &gt; </td></tr>
<tr class="memitem:a1f71883e0a08588f121d7ab696a42cbd"><td class="memTemplItemLeft" align="right" valign="top">R&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceillumina_1_1interop_1_1util.html#a1f71883e0a08588f121d7ab696a42cbd">variance</a> (I beg, I end, BinaryOp op)</td></tr>
<tr class="separator:a1f71883e0a08588f121d7ab696a42cbd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4a10aca8c26fe5844e22c4c63e0c13a7"><td class="memTemplParams" colspan="2">template&lt;typename R , typename I &gt; </td></tr>
<tr class="memitem:a4a10aca8c26fe5844e22c4c63e0c13a7"><td class="memTemplItemLeft" align="right" valign="top">R&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceillumina_1_1interop_1_1util.html#a4a10aca8c26fe5844e22c4c63e0c13a7">mean</a> (I beg, I end)</td></tr>
<tr class="separator:a4a10aca8c26fe5844e22c4c63e0c13a7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a81c37dec8b3da932b68d629fb1116581"><td class="memTemplParams" colspan="2">template&lt;typename R , typename I &gt; </td></tr>
<tr class="memitem:a81c37dec8b3da932b68d629fb1116581"><td class="memTemplItemLeft" align="right" valign="top">R&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceillumina_1_1interop_1_1util.html#a81c37dec8b3da932b68d629fb1116581">variance</a> (I beg, I end)</td></tr>
<tr class="separator:a81c37dec8b3da932b68d629fb1116581"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a20dc979212d500d172551c5f7604c507"><td class="memTemplParams" colspan="2">template&lt;typename R , typename I &gt; </td></tr>
<tr class="memitem:a20dc979212d500d172551c5f7604c507"><td class="memTemplItemLeft" align="right" valign="top">R&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceillumina_1_1interop_1_1util.html#a20dc979212d500d172551c5f7604c507">variance_with_mean</a> (I beg, I end, const R <a class="el" href="namespaceillumina_1_1interop_1_1util.html#a2031849375ca583266a2b24181c9e2be">mean</a>)</td></tr>
<tr class="separator:a20dc979212d500d172551c5f7604c507"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a65d4dc98570a2f1cf187382b0793a100"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceillumina_1_1interop_1_1util.html#a65d4dc98570a2f1cf187382b0793a100">replace</a> (std::string &amp;str, const std::string &amp;from, const std::string &amp;to)</td></tr>
<tr class="separator:a65d4dc98570a2f1cf187382b0793a100"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaf9b3451c623c29ba89c4565305d79a1"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceillumina_1_1interop_1_1util.html#aaf9b3451c623c29ba89c4565305d79a1">camel_to</a> (std::string &amp;str, const std::string &amp;sep=&quot; &quot;)</td></tr>
<tr class="separator:aaf9b3451c623c29ba89c4565305d79a1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8fe7d756fe6d0a340b6d501dd46e4210"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceillumina_1_1interop_1_1util.html#a8fe7d756fe6d0a340b6d501dd46e4210">camel_from</a> (std::string &amp;str, const char sep=' ')</td></tr>
<tr class="separator:a8fe7d756fe6d0a340b6d501dd46e4210"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a665ce491b909e304d9a141b9295eb41a"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceillumina_1_1interop_1_1util.html#a665ce491b909e304d9a141b9295eb41a">contains_ASCII_only</a> (const std::string &amp;input)</td></tr>
<tr class="separator:a665ce491b909e304d9a141b9295eb41a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a47aefec0042bb7ffb673d4f6ede63547"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceillumina_1_1interop_1_1util.html#a47aefec0042bb7ffb673d4f6ede63547">to_lower</a> (const std::string &amp;input)</td></tr>
<tr class="separator:a47aefec0042bb7ffb673d4f6ede63547"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a230b5170e546bf6cf99e52fc686423e7"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceillumina_1_1interop_1_1util.html#a230b5170e546bf6cf99e52fc686423e7">ends_with</a> (const std::string &amp;input, const std::string &amp;ending, const bool is_case_insensitive=false)</td></tr>
<tr class="separator:a230b5170e546bf6cf99e52fc686423e7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6c61786a1849a9756a98a09089f371e7"><td class="memItemLeft" align="right" valign="top">std::istream &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceillumina_1_1interop_1_1util.html#a6c61786a1849a9756a98a09089f371e7">cross_platform_getline</a> (std::istream &amp;is, std::string &amp;line)</td></tr>
<tr class="separator:a6c61786a1849a9756a98a09089f371e7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aea26d3f96b9928cccc4c96bfe2faae02"><td class="memItemLeft" align="right" valign="top">std::istream &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceillumina_1_1interop_1_1util.html#aea26d3f96b9928cccc4c96bfe2faae02">operator&gt;&gt;</a> (std::istream &amp;in, <a class="el" href="group__constants.html#gac4500f05fcb88f71ee5caece09e9afc4">constants::dna_bases</a> &amp;bases)</td></tr>
<tr class="separator:aea26d3f96b9928cccc4c96bfe2faae02"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a63185fad6dc1ee4e2cda47752d0e08ed"><td class="memItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceillumina_1_1interop_1_1util.html#a63185fad6dc1ee4e2cda47752d0e08ed">operator&lt;&lt;</a> (std::ostream &amp;out, const <a class="el" href="structillumina_1_1interop_1_1util_1_1csharp__date__time.html">csharp_date_time</a> &amp;date_time)</td></tr>
<tr class="separator:a63185fad6dc1ee4e2cda47752d0e08ed"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0ec28cd1cdf95ccb441712b102e43f03"><td class="memItemLeft" align="right" valign="top">std::istream &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceillumina_1_1interop_1_1util.html#a0ec28cd1cdf95ccb441712b102e43f03">operator&gt;&gt;</a> (std::istream &amp;in, <a class="el" href="structillumina_1_1interop_1_1util_1_1csharp__date__time.html">csharp_date_time</a> &amp;date_time)</td></tr>
<tr class="separator:a0ec28cd1cdf95ccb441712b102e43f03"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<h2 class="groupheader">Function Documentation</h2>
<a class="anchor" id="a8fe7d756fe6d0a340b6d501dd46e4210"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void illumina::interop::util::camel_from </td>
          <td>(</td>
          <td class="paramtype">std::string &amp;&#160;</td>
          <td class="paramname"><em>str</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char&#160;</td>
          <td class="paramname"><em>sep</em> = <code>'&#160;'</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Split string based on space characters and delineate with camel case</p>
<p>E.g. "Signal To Noise" -&gt; "SignalToNoise"</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">str</td><td>source/destination string </td></tr>
    <tr><td class="paramname">sep</td><td>separator string </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="aaf9b3451c623c29ba89c4565305d79a1"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void illumina::interop::util::camel_to </td>
          <td>(</td>
          <td class="paramtype">std::string &amp;&#160;</td>
          <td class="paramname"><em>str</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>sep</em> = <code>&quot;&#160;&quot;</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Split string based on upper case characters and separate with separator string</p>
<p>E.g. "SignalToNoise" -&gt; "Signal To Noise"</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">str</td><td>source/destination string </td></tr>
    <tr><td class="paramname">sep</td><td>seperator string </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="afdcbece3327f898cdc9516ebcc075afb"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const Value&amp; illumina::interop::util::constant_mapping_get </td>
          <td>(</td>
          <td class="paramtype">const std::pair&lt; Key, Value &gt;(&amp;)&#160;</td>
          <td class="paramname"><em>pairs</em>[N], </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Key &amp;&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Value &amp;&#160;</td>
          <td class="paramname"><em>default_value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Get the value corresponding to the key or default_value if none exists</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pairs</td><td>array of values mapping Key to Value </td></tr>
    <tr><td class="paramname">key</td><td>key to search for in mapping </td></tr>
    <tr><td class="paramname">default_value</td><td>value to return if the key is not found </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>value found (or default_value) </dd></dl>

</div>
</div>
<a class="anchor" id="a665ce491b909e304d9a141b9295eb41a"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool illumina::interop::util::contains_ASCII_only </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>input</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns true iff only ASCII characters are used</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">input</td><td>string to check </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a6c61786a1849a9756a98a09089f371e7"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::istream&amp; illumina::interop::util::cross_platform_getline </td>
          <td>(</td>
          <td class="paramtype">std::istream &amp;&#160;</td>
          <td class="paramname"><em>is</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string &amp;&#160;</td>
          <td class="paramname"><em>line</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="a230b5170e546bf6cf99e52fc686423e7"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool illumina::interop::util::ends_with </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>input</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>ending</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool&#160;</td>
          <td class="paramname"><em>is_case_insensitive</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="a31e479779f58a3fd59052c18abf63ebc"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">float illumina::interop::util::float_cast </td>
          <td>(</td>
          <td class="paramtype">const T&#160;</td>
          <td class="paramname"><em>val</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T&#160;</td>
          <td class="paramname"><em>sentinel</em> = <code>std::numeric_limits&lt;T&gt;::max()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Cast a number to a float, return NaN if it matches the sentinel</p>
<p>The default sentinel is the maximum value for the type.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">val</td><td>number to cast </td></tr>
    <tr><td class="paramname">sentinel</td><td>NaN sentinel, default max value </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd></dd></dl>

</div>
</div>
<a class="anchor" id="af7e80564fd7e8e5fbff5dde1d6b9ad41"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::string illumina::interop::util::format </td>
          <td>(</td>
          <td class="paramtype">const float&#160;</td>
          <td class="paramname"><em>val</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>width</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>precision</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char&#160;</td>
          <td class="paramname"><em>fill</em> = <code>'&#160;'</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool&#160;</td>
          <td class="paramname"><em>fixed</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Utility to format a floating point number as a string</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">val</td><td>floating point value </td></tr>
    <tr><td class="paramname">width</td><td>width of the number </td></tr>
    <tr><td class="paramname">precision</td><td>number of digits after decimal </td></tr>
    <tr><td class="paramname">fill</td><td>fill character </td></tr>
    <tr><td class="paramname">fixed</td><td>if true use fixed not default </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>string representation of float </dd></dl>

</div>
</div>
<a class="anchor" id="a9fe29328dd1979e022b48a3c4cfe1b1b"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">F illumina::interop::util::interpolate_linear </td>
          <td>(</td>
          <td class="paramtype">const F&#160;</td>
          <td class="paramname"><em>y1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const F&#160;</td>
          <td class="paramname"><em>y2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const F&#160;</td>
          <td class="paramname"><em>x1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const F&#160;</td>
          <td class="paramname"><em>x2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const F&#160;</td>
          <td class="paramname"><em>xt</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Perform linear interpolation between two sets of (x,y) points given a target x value</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">y1</td><td>y-value for point 1 </td></tr>
    <tr><td class="paramname">y2</td><td>y-value for point 2 </td></tr>
    <tr><td class="paramname">x1</td><td>x-value for point 1 </td></tr>
    <tr><td class="paramname">x2</td><td>x-value for point 2 </td></tr>
    <tr><td class="paramname">xt</td><td>target x-value </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>linearly interoploate y-value for given target x value </dd></dl>

</div>
</div>
<a class="anchor" id="aba0e191a6382d97a3931c087e05d2907"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t illumina::interop::util::length_of </td>
          <td>(</td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>val</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Get the number of elements in the collection or 1 if a value</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">val</td><td>collection or value </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>size of collection or 1 for value </dd></dl>

</div>
</div>
<a class="anchor" id="a9eb3978dbfbd02949f5ccdfe663ed4d4"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t illumina::interop::util::length_of </td>
          <td>(</td>
          <td class="paramtype">const &#160;</td>
          <td class="paramname"><em>T</em>(&amp;)[N]</td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Get the number of elements in a stack array</p>
<dl class="section return"><dt>Returns</dt><dd>size of array </dd></dl>

</div>
</div>
<a class="anchor" id="a4ad6e9ed14d61c6379784ac331ceb6c2"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Destination illumina::interop::util::lexical_cast </td>
          <td>(</td>
          <td class="paramtype">const Source &amp;&#160;</td>
          <td class="paramname"><em>src</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Cast between a string type and some arbitrary type</p>
<dl class="section note"><dt>Note</dt><dd>The arbitrary type should support the std::istream &gt;&gt; or std::ostream &lt;&lt; operators</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">src</td><td>source value of an arbitrary type </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>value of arbitrary type </dd></dl>

</div>
</div>
<a class="anchor" id="a2031849375ca583266a2b24181c9e2be"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">R illumina::interop::util::mean </td>
          <td>(</td>
          <td class="paramtype">I&#160;</td>
          <td class="paramname"><em>beg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">I&#160;</td>
          <td class="paramname"><em>end</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">BinaryOp&#160;</td>
          <td class="paramname"><em>op</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Estimate the mean of values in a given collection</p>
<p>Usage: std::vector&lt;float&gt; values = {0,1,2,3}; double mean_val = mean&lt;double&gt;(values.begin(), values.end());</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">beg</td><td>iterator to start of collection </td></tr>
    <tr><td class="paramname">end</td><td>iterator to end of collection </td></tr>
    <tr><td class="paramname">op</td><td>function that takes one value and returns another value </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>mean of the input collection </dd></dl>

</div>
</div>
<a class="anchor" id="a4a10aca8c26fe5844e22c4c63e0c13a7"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">R illumina::interop::util::mean </td>
          <td>(</td>
          <td class="paramtype">I&#160;</td>
          <td class="paramname"><em>beg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">I&#160;</td>
          <td class="paramname"><em>end</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Estimate the mean of values in a given collection</p>
<p>Usage: std::vector&lt;float&gt; values = {0,1,2,3}; double mean_val = mean&lt;double&gt;(values.begin(), values.end());</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">beg</td><td>iterator to start of collection </td></tr>
    <tr><td class="paramname">end</td><td>iterator to end of collection </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>mean of the input collection </dd></dl>

</div>
</div>
<a class="anchor" id="a013f14849308448e6b3f3aff315a7a4e"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">I illumina::interop::util::median </td>
          <td>(</td>
          <td class="paramtype">I&#160;</td>
          <td class="paramname"><em>beg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">I&#160;</td>
          <td class="paramname"><em>end</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Calculate the median of the collection</p>
<dl class="section note"><dt>Note</dt><dd>this will change the underlying array!</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">beg</td><td>iterator to start of collection </td></tr>
    <tr><td class="paramname">end</td><td>iterator to end of collection </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>iterator to requested percentile </dd></dl>

</div>
</div>
<a class="anchor" id="a1c0316a0e324ee511e7ede2110ef156f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">I illumina::interop::util::median </td>
          <td>(</td>
          <td class="paramtype">I&#160;</td>
          <td class="paramname"><em>beg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">I&#160;</td>
          <td class="paramname"><em>end</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Compare&#160;</td>
          <td class="paramname"><em>comp</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Calculate the median of the collection</p>
<dl class="section note"><dt>Note</dt><dd>this will change the underlying array!</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">beg</td><td>iterator to start of collection </td></tr>
    <tr><td class="paramname">end</td><td>iterator to end of collection </td></tr>
    <tr><td class="paramname">comp</td><td>comparator between two types </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>iterator to requested percentile </dd></dl>

</div>
</div>
<a class="anchor" id="a7a541cc6fe2b6d9eb48ec5970b709a13"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">F illumina::interop::util::median_interpolated </td>
          <td>(</td>
          <td class="paramtype">I&#160;</td>
          <td class="paramname"><em>beg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">I&#160;</td>
          <td class="paramname"><em>end</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Calculate the median of the collection</p>
<dl class="section note"><dt>Note</dt><dd>this will change the underlying array!</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">beg</td><td>iterator to start of collection </td></tr>
    <tr><td class="paramname">end</td><td>iterator to end of collection </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>iterator to requested percentile </dd></dl>

</div>
</div>
<a class="anchor" id="a0733552eca182f2d917c02523020c81a"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">F illumina::interop::util::median_interpolated </td>
          <td>(</td>
          <td class="paramtype">I&#160;</td>
          <td class="paramname"><em>beg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">I&#160;</td>
          <td class="paramname"><em>end</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Compare&#160;</td>
          <td class="paramname"><em>comp</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Calculate the median of the collection</p>
<dl class="section note"><dt>Note</dt><dd>this will change the underlying array!</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">beg</td><td>iterator to start of collection </td></tr>
    <tr><td class="paramname">end</td><td>iterator to end of collection </td></tr>
    <tr><td class="paramname">comp</td><td>comparator between two types </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>iterator to requested percentile </dd></dl>

</div>
</div>
<a class="anchor" id="a0838a1b75c4b3bd2fc9fd67b7dcaed53"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">F illumina::interop::util::median_interpolated </td>
          <td>(</td>
          <td class="paramtype">I&#160;</td>
          <td class="paramname"><em>beg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">I&#160;</td>
          <td class="paramname"><em>end</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Compare&#160;</td>
          <td class="paramname"><em>comp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Op&#160;</td>
          <td class="paramname"><em>op</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Calculate the median of the collection</p>
<dl class="section note"><dt>Note</dt><dd>this will change the underlying array!</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">beg</td><td>iterator to start of collection </td></tr>
    <tr><td class="paramname">end</td><td>iterator to end of collection </td></tr>
    <tr><td class="paramname">comp</td><td>comparator between two types </td></tr>
    <tr><td class="paramname">op</td><td>function that takes one value and returns another value </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>iterator to requested percentile </dd></dl>

</div>
</div>
<a class="anchor" id="a8a4ef71819a384de1855c3a550c1ad5b"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">R illumina::interop::util::nan_mean </td>
          <td>(</td>
          <td class="paramtype">I&#160;</td>
          <td class="paramname"><em>beg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">I&#160;</td>
          <td class="paramname"><em>end</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">BinaryOp&#160;</td>
          <td class="paramname"><em>op</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Estimate the mean of values in a given collection</p>
<p>This function skips NaN values</p>
<p>Usage: std::vector&lt;float&gt; values = {0,1,2,3}; double mean_val = nan_mean&lt;double&gt;(values.begin(), values.end());</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">beg</td><td>iterator to start of collection </td></tr>
    <tr><td class="paramname">end</td><td>iterator to end of collection </td></tr>
    <tr><td class="paramname">op</td><td>function that takes one value and returns another value </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>mean of the input collection </dd></dl>

</div>
</div>
<a class="anchor" id="a6bd55e46e90bd70a8a5bac9e100d9569"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">R illumina::interop::util::nan_variance </td>
          <td>(</td>
          <td class="paramtype">I&#160;</td>
          <td class="paramname"><em>beg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">I&#160;</td>
          <td class="paramname"><em>end</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">BinaryOp&#160;</td>
          <td class="paramname"><em>op</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Estimate the variance of values in a given collection</p>
<p>This function skips NaN values</p>
<p>Usage: std::vector&lt;float&gt; values = {0,1,2,3}; double var_val = nan_variance&lt;double&gt;(values.begin(), values.end());</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">beg</td><td>iterator to start of collection </td></tr>
    <tr><td class="paramname">end</td><td>iterator to end of collection </td></tr>
    <tr><td class="paramname">op</td><td>function that takes one value and returns another value </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>variance of the input collection </dd></dl>

</div>
</div>
<a class="anchor" id="aad6d0943990f6a951872fca1717bdc84"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">R illumina::interop::util::nan_variance_with_mean </td>
          <td>(</td>
          <td class="paramtype">I&#160;</td>
          <td class="paramname"><em>beg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">I&#160;</td>
          <td class="paramname"><em>end</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const R&#160;</td>
          <td class="paramname"><em>mean_val</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">BinaryOp&#160;</td>
          <td class="paramname"><em>op</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Estimate the variance of values in a given collection</p>
<p>This function skips NaN values</p>
<p>Usage: std::vector&lt;float&gt; values = {0,1,2,3}; double var_val = nan_variance&lt;double&gt;(values.begin(), values.end());</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">beg</td><td>iterator to start of collection </td></tr>
    <tr><td class="paramname">end</td><td>iterator to end of collection </td></tr>
    <tr><td class="paramname">mean_val</td><td>pre-calculated mean </td></tr>
    <tr><td class="paramname">op</td><td>function that takes one value and returns another value </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>variance of the input collection </dd></dl>

</div>
</div>
<a class="anchor" id="a63185fad6dc1ee4e2cda47752d0e08ed"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::ostream&amp; illumina::interop::util::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structillumina_1_1interop_1_1util_1_1csharp__date__time.html">csharp_date_time</a> &amp;&#160;</td>
          <td class="paramname"><em>date_time</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Write date type as integer to an output stream</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">out</td><td>output stream </td></tr>
    <tr><td class="paramname">date_time</td><td>data time object </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>output stream </dd></dl>

</div>
</div>
<a class="anchor" id="aea26d3f96b9928cccc4c96bfe2faae02"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::istream&amp; illumina::interop::util::operator&gt;&gt; </td>
          <td>(</td>
          <td class="paramtype">std::istream &amp;&#160;</td>
          <td class="paramname"><em>in</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__constants.html#gac4500f05fcb88f71ee5caece09e9afc4">constants::dna_bases</a> &amp;&#160;</td>
          <td class="paramname"><em>bases</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="a0ec28cd1cdf95ccb441712b102e43f03"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::istream&amp; illumina::interop::util::operator&gt;&gt; </td>
          <td>(</td>
          <td class="paramtype">std::istream &amp;&#160;</td>
          <td class="paramname"><em>in</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structillumina_1_1interop_1_1util_1_1csharp__date__time.html">csharp_date_time</a> &amp;&#160;</td>
          <td class="paramname"><em>date_time</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Read a date type from the input stream</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">in</td><td>input stream </td></tr>
    <tr><td class="paramname">date_time</td><td>data time object </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>input stream </dd></dl>

</div>
</div>
<a class="anchor" id="aa3fb290d02820e5caa24b9275993c3bc"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void illumina::interop::util::outliers_lower </td>
          <td>(</td>
          <td class="paramtype">I&#160;</td>
          <td class="paramname"><em>beg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">I&#160;</td>
          <td class="paramname"><em>end</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const F&#160;</td>
          <td class="paramname"><em>bound</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">O&#160;</td>
          <td class="paramname"><em>out</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Collect outliers below bound for a sorted collection</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">beg</td><td>iterator to start of a sorted collection </td></tr>
    <tr><td class="paramname">end</td><td>iterator to end of a sorted collection </td></tr>
    <tr><td class="paramname">bound</td><td>bounding value for outliers </td></tr>
    <tr><td class="paramname">out</td><td>output iterator </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a8be6288c1dc05281975e45f8463215a1"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void illumina::interop::util::outliers_upper </td>
          <td>(</td>
          <td class="paramtype">I&#160;</td>
          <td class="paramname"><em>beg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">I&#160;</td>
          <td class="paramname"><em>end</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const F&#160;</td>
          <td class="paramname"><em>bound</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">O&#160;</td>
          <td class="paramname"><em>out</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Collect outliers above bound for a sorted collection</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">beg</td><td>iterator to start of a sorted collection </td></tr>
    <tr><td class="paramname">end</td><td>iterator to end of a sorted collection </td></tr>
    <tr><td class="paramname">bound</td><td>bounding value for outliers </td></tr>
    <tr><td class="paramname">out</td><td>output iterator </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a54a97a439caba7e4866575703cbcc404"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">I illumina::interop::util::percentile </td>
          <td>(</td>
          <td class="paramtype">I&#160;</td>
          <td class="paramname"><em>beg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">I&#160;</td>
          <td class="paramname"><em>end</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const size_t&#160;</td>
          <td class="paramname"><em>percentile</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Calculate the given percentile</p>
<p>The percentile must be an integer in percent. For example the 99th percent tile would set percentile = 99.</p>
<dl class="section note"><dt>Note</dt><dd>this will change the underlying array!</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">beg</td><td>iterator to start of collection </td></tr>
    <tr><td class="paramname">end</td><td>iterator to end of collection </td></tr>
    <tr><td class="paramname">percentile</td><td>integer in percent </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>iterator to requested percentile </dd></dl>

</div>
</div>
<a class="anchor" id="ac594a00c4497eed8de9baad5f52d6fa9"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">I illumina::interop::util::percentile </td>
          <td>(</td>
          <td class="paramtype">I&#160;</td>
          <td class="paramname"><em>beg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">I&#160;</td>
          <td class="paramname"><em>end</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const size_t&#160;</td>
          <td class="paramname"><em>percentile</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Compare&#160;</td>
          <td class="paramname"><em>comp</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Calculate the given percentile</p>
<p>The percentile must be an integer in percent. For example the 99th percent tile would set percentile = 99.</p>
<dl class="section note"><dt>Note</dt><dd>this will change the underlying array!</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">beg</td><td>iterator to start of collection </td></tr>
    <tr><td class="paramname">end</td><td>iterator to end of collection </td></tr>
    <tr><td class="paramname">percentile</td><td>integer in percent </td></tr>
    <tr><td class="paramname">comp</td><td>comparator between two types </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>iterator to requested percentile </dd></dl>

</div>
</div>
<a class="anchor" id="a0dcdea84d6f1c1d93a0b0cb16920daf0"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">F illumina::interop::util::percentile_sorted </td>
          <td>(</td>
          <td class="paramtype">I&#160;</td>
          <td class="paramname"><em>beg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">I&#160;</td>
          <td class="paramname"><em>end</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const size_t&#160;</td>
          <td class="paramname"><em>percentile</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Calculate the interpolated percentile given a sorted array</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">beg</td><td>iterator to start of sorted array </td></tr>
    <tr><td class="paramname">end</td><td>iterator to end of sorted array </td></tr>
    <tr><td class="paramname">percentile</td><td>target percentile [0-100] </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>interpolated value of array corresponding to given percentile </dd></dl>

</div>
</div>
<a class="anchor" id="abaf3af7779b9d340cba9d51c138e264e"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">F illumina::interop::util::percentile_sorted </td>
          <td>(</td>
          <td class="paramtype">I&#160;</td>
          <td class="paramname"><em>beg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">I&#160;</td>
          <td class="paramname"><em>end</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const size_t&#160;</td>
          <td class="paramname"><em>percentile</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Op&#160;</td>
          <td class="paramname"><em>op</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Calculate the interpolated percentile given a sorted array</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">beg</td><td>iterator to start of sorted array </td></tr>
    <tr><td class="paramname">end</td><td>iterator to end of sorted array </td></tr>
    <tr><td class="paramname">percentile</td><td>target percentile [0-100] </td></tr>
    <tr><td class="paramname">op</td><td>function that takes one value and returns another value </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>interpolated value of array corresponding to given percentile </dd></dl>

</div>
</div>
<a class="anchor" id="a26c663639533827578ff07630ca16784"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">I illumina::interop::util::remove_nan </td>
          <td>(</td>
          <td class="paramtype">I&#160;</td>
          <td class="paramname"><em>beg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">I&#160;</td>
          <td class="paramname"><em>end</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">UnaryOp&#160;</td>
          <td class="paramname"><em>op</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Sort NaNs to the end of the collection return iterator to first NaN value</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">beg</td><td>iterator to start of collection </td></tr>
    <tr><td class="paramname">end</td><td>iterator to end of collection </td></tr>
    <tr><td class="paramname">op</td><td>function that takes one value and returns another value </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>iterator to last non-NaN element </dd></dl>

</div>
</div>
<a class="anchor" id="a65d4dc98570a2f1cf187382b0793a100"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool illumina::interop::util::replace </td>
          <td>(</td>
          <td class="paramtype">std::string &amp;&#160;</td>
          <td class="paramname"><em>str</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>from</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>to</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Replace any first occurence of substring from with substring to</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">str</td><td>source/destination string </td></tr>
    <tr><td class="paramname">from</td><td>search string </td></tr>
    <tr><td class="paramname">to</td><td>replacement string </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if substring was found and replaced </dd></dl>

</div>
</div>
<a class="anchor" id="a47aefec0042bb7ffb673d4f6ede63547"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::string illumina::interop::util::to_lower </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>input</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="a1f71883e0a08588f121d7ab696a42cbd"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">R illumina::interop::util::variance </td>
          <td>(</td>
          <td class="paramtype">I&#160;</td>
          <td class="paramname"><em>beg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">I&#160;</td>
          <td class="paramname"><em>end</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">BinaryOp&#160;</td>
          <td class="paramname"><em>op</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Estimate the variance of values in a given collection</p>
<p>Usage: std::vector&lt;float&gt; values = {0,1,2,3}; double var_val = variance&lt;double&gt;(values.begin(), values.end());</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">beg</td><td>iterator to start of collection </td></tr>
    <tr><td class="paramname">end</td><td>iterator to end of collection </td></tr>
    <tr><td class="paramname">op</td><td>function that takes one value and returns another value </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>variance of the input collection </dd></dl>

</div>
</div>
<a class="anchor" id="a81c37dec8b3da932b68d629fb1116581"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">R illumina::interop::util::variance </td>
          <td>(</td>
          <td class="paramtype">I&#160;</td>
          <td class="paramname"><em>beg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">I&#160;</td>
          <td class="paramname"><em>end</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Estimate the variance of values in a given collection</p>
<p>Usage: std::vector&lt;float&gt; values = {0,1,2,3}; double mean_val = variance&lt;double&gt;(values.begin(), values.end());</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">beg</td><td>iterator to start of collection </td></tr>
    <tr><td class="paramname">end</td><td>iterator to end of collection </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>variance of the input collection </dd></dl>

</div>
</div>
<a class="anchor" id="ac6e881e574ffb6b541620d93492b5169"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">R illumina::interop::util::variance_with_mean </td>
          <td>(</td>
          <td class="paramtype">I&#160;</td>
          <td class="paramname"><em>beg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">I&#160;</td>
          <td class="paramname"><em>end</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const R&#160;</td>
          <td class="paramname"><em>mean_val</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">BinaryOp&#160;</td>
          <td class="paramname"><em>op</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Estimate the variance of values in a given collection</p>
<p>Usage: std::vector&lt;float&gt; values = {0,1,2,3}; double var_val = variance&lt;double&gt;(values.begin(), values.end());</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">beg</td><td>iterator to start of collection </td></tr>
    <tr><td class="paramname">end</td><td>iterator to end of collection </td></tr>
    <tr><td class="paramname">mean_val</td><td>precalculated mean </td></tr>
    <tr><td class="paramname">op</td><td>function that takes one value and returns another value </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>variance of the input collection </dd></dl>

</div>
</div>
<a class="anchor" id="a20dc979212d500d172551c5f7604c507"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">R illumina::interop::util::variance_with_mean </td>
          <td>(</td>
          <td class="paramtype">I&#160;</td>
          <td class="paramname"><em>beg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">I&#160;</td>
          <td class="paramname"><em>end</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const R&#160;</td>
          <td class="paramname"><em>mean</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Estimate the variance of values in a given collection</p>
<p>Usage: std::vector&lt;float&gt; values = {0,1,2,3}; double mean_val = variance&lt;double&gt;(values.begin(), values.end());</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">beg</td><td>iterator to start of collection </td></tr>
    <tr><td class="paramname">end</td><td>iterator to end of collection </td></tr>
    <tr><td class="paramname">mean</td><td>mean of the data in the collection </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>variance of the input collection </dd></dl>

</div>
</div>
<a class="anchor" id="a85663336098d396b34a87db5a66b37d7"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classillumina_1_1interop_1_1util_1_1value__container.html">value_container</a>&lt; R (T::* )(P1) &gt; illumina::interop::util::wrap_setter </td>
          <td>(</td>
          <td class="paramtype">T &amp;&#160;</td>
          <td class="paramname"><em>obj</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">R(T::*)(P1)&#160;</td>
          <td class="paramname"><em>func</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Wrapper memeber function setter</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">obj</td><td>reference to object </td></tr>
    <tr><td class="paramname">func</td><td>pointer ot member function setting </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>value_container </dd></dl>

</div>
</div>
</div><!-- contents -->
<!-- HTML footer for doxygen 1.8.10-->
<!-- start footer part -->
<hr class="footer"/>
</body>
</html>
