<!-- HTML header for doxygen 1.8.8-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
 <meta http-equiv="X-UA-Compatible" content="IE=edge">
 <!-- For Mobile Devices -->
 <meta name="viewport" content="width=device-width, initial-scale=1">
 <!-- Loading Lato Font -->
 <link href='https://fonts.googleapis.com/css?family=Lato:300,400,700,300italic,400italic,700italic' rel='stylesheet' type='text/css'>
 <!-- Loading Font Awesome -->
 <link rel="stylesheet" href="https://maxcdn.bootstrapcdn.com/font-awesome/4.3.0/css/font-awesome.min.css">
 <meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
 <meta name="generator" content="Doxygen 1.8.10"/>
 <script type="text/javascript" src="https://code.jquery.com/jquery-2.1.1.min.js"></script>
 <script>
  (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
  (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
  m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
  })(window,document,'script','https://www.google-analytics.com/analytics.js','ga');
  ga('create', 'UA-88338608-1', 'auto');
  ga('send', 'pageview');
</script>
 <title>illumina::interop::logic::utils Namespace Reference</title>
 <!--<link href="tabs.css" rel="stylesheet" type="text/css"/>-->
 <script type="text/javascript" src="dynsections.js"></script>
 <link href="doxygen.css" rel="stylesheet" type="text/css" />
 <link href="customdoxygen.css" rel="stylesheet" type="text/css" />
 <link rel="stylesheet" href="bootstrap3/css/bootstrap.min.css">
 <link href="bootstrap3/css/sticky-footer-navbar.css" rel="stylesheet">
 <script src="bootstrap3/js/bootstrap.min.js"></script>
 <script type="text/javascript" src="doxy-boot.js"></script>
</head>
<body screen_capture_injected="true">
<nav class="navbar navbar-inverse" role="navigation">
 <div class="container">
  <div class="navbar-header">
   <a class="navbar-brand" href="https://www.illumina.com/"><img style='margin-top: -8px !important;height: 40px !important;' src='ILLUMINA_LOGO_RGB_new_200_45.png' /></a>
   <a class="navbar-brand">InterOp <span style="font-size: 10pt">v1.1.28</span>  </a>
  </div>
  <div class="collapse navbar-collapse">
   <!-- Left -->
   <ul class="nav navbar-nav adjust-right">
    <li><a href="https://github.com/Illumina/interop">Code</a></li>
    <li><a href="https://github.com/Illumina/interop/issues">Issues</a></li>
    <li><a href="https://github.com/Illumina/interop/releases/latest">Download</a></li>
   </ul>
  </div><!--/.nav-collapse -->
 </div>
</nav>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
 <div class="content" id="content">
  <div class="container">
   <div class="row">
    <div class="col-sm-12 panel panel-default" style="padding-bottom: 15px;">
     <div style="margin-bottom: 15px;">
      <!-- end header part -->
<!-- Generated by Doxygen 1.8.10 -->
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Home</span></a></li>
      <li><a href="pages.html"><span>Index</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="namespacemembers.html"><span>Namespace&#160;Members</span></a></li>
    </ul>
  </div>
<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespaceillumina.html">illumina</a></li><li class="navelem"><a class="el" href="namespaceillumina_1_1interop.html">interop</a></li><li class="navelem"><a class="el" href="namespaceillumina_1_1interop_1_1logic.html">logic</a></li><li class="navelem"><a class="el" href="namespaceillumina_1_1interop_1_1logic_1_1utils.html">utils</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#typedef-members">Typedefs</a> &#124;
<a href="#func-members">Functions</a> &#124;
<a href="#var-members">Variables</a>  </div>
  <div class="headertitle">
<div class="title">illumina::interop::logic::utils Namespace Reference</div>  </div>
</div><!--header-->
<div class="contents">
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr class="memitem:ae746ca0acad282c67a43c2dad9abe945"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="classillumina_1_1interop_1_1constants_1_1enum__description.html">constants::enum_description</a>&lt; <a class="el" href="group__constants.html#ga7eb7e5452c2cfdd477b95baae0a1794f">constants::metric_type</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceillumina_1_1interop_1_1logic_1_1utils.html#ae746ca0acad282c67a43c2dad9abe945">metric_type_description_t</a></td></tr>
<tr class="separator:ae746ca0acad282c67a43c2dad9abe945"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:a83f9d5e6ba2e0d2e0104334f70d32b46"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceillumina_1_1interop_1_1logic_1_1utils.html#a83f9d5e6ba2e0d2e0104334f70d32b46">normalize</a> (const std::string &amp;channel)</td></tr>
<tr class="separator:a83f9d5e6ba2e0d2e0104334f70d32b46"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6122d6ca92696f10f3863296cc74e9c1"><td class="memTemplParams" colspan="2">template&lt;class I , class O &gt; </td></tr>
<tr class="memitem:a6122d6ca92696f10f3863296cc74e9c1"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceillumina_1_1interop_1_1logic_1_1utils.html#a6122d6ca92696f10f3863296cc74e9c1">normalize</a> (I beg, I end, O out)</td></tr>
<tr class="separator:a6122d6ca92696f10f3863296cc74e9c1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a37db8691e8f774366b2eed13c6d2cc58"><td class="memTemplParams" colspan="2">template&lt;class I &gt; </td></tr>
<tr class="memitem:a37db8691e8f774366b2eed13c6d2cc58"><td class="memTemplItemLeft" align="right" valign="top">std::string&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceillumina_1_1interop_1_1logic_1_1utils.html#a37db8691e8f774366b2eed13c6d2cc58">join</a> (I beg, I end, const std::string &amp;token)</td></tr>
<tr class="separator:a37db8691e8f774366b2eed13c6d2cc58"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a06afc34edd2a54160f0eff8fd897b513"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceillumina_1_1interop_1_1logic_1_1utils.html#a06afc34edd2a54160f0eff8fd897b513">join</a> (const std::vector&lt; std::string &gt; &amp;values, const std::string &amp;token)</td></tr>
<tr class="separator:a06afc34edd2a54160f0eff8fd897b513"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a50038a8f941214e930c2d42195688bc8"><td class="memTemplParams" colspan="2">template&lt;class I &gt; </td></tr>
<tr class="memitem:a50038a8f941214e930c2d42195688bc8"><td class="memTemplItemLeft" align="right" valign="top">std::vector&lt; std::string &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceillumina_1_1interop_1_1logic_1_1utils.html#a50038a8f941214e930c2d42195688bc8">expected_order</a> (I beg, I end) <a class="el" href="exception__specification_8h.html#aff57a57f70bd067a95a801be66b24b4e">INTEROP_THROW_SPEC</a>((model</td></tr>
<tr class="separator:a50038a8f941214e930c2d42195688bc8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adf2be7941e65e6f65b963742b04348b4"><td class="memItemLeft" align="right" valign="top">std::vector&lt; std::string &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceillumina_1_1interop_1_1logic_1_1utils.html#adf2be7941e65e6f65b963742b04348b4">expected_order</a> (const std::vector&lt; std::string &gt; &amp;channels)</td></tr>
<tr class="separator:adf2be7941e65e6f65b963742b04348b4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5787505c314cdab120d46405666788eb"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceillumina_1_1interop_1_1logic_1_1utils.html#a5787505c314cdab120d46405666788eb">expected2actual</a> (const std::vector&lt; std::string &gt; &amp;channels, std::vector&lt; size_t &gt; &amp;map)</td></tr>
<tr class="separator:a5787505c314cdab120d46405666788eb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6dce24320ac2ef6a132b75fccd331230"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceillumina_1_1interop_1_1logic_1_1utils.html#a6dce24320ac2ef6a132b75fccd331230">actual2expected</a> (const std::vector&lt; std::string &gt; &amp;channels, std::vector&lt; size_t &gt; &amp;map)</td></tr>
<tr class="separator:a6dce24320ac2ef6a132b75fccd331230"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af69bb7fd7efa2c545746ca29e9b2e6c1"><td class="memItemLeft" align="right" valign="top">std::vector&lt; size_t &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceillumina_1_1interop_1_1logic_1_1utils.html#af69bb7fd7efa2c545746ca29e9b2e6c1">expected2actual_map</a> (const std::vector&lt; std::string &gt; &amp;channels)</td></tr>
<tr class="separator:af69bb7fd7efa2c545746ca29e9b2e6c1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae6a10f3c0bf133ada1bbe88d1b025544"><td class="memItemLeft" align="right" valign="top">std::vector&lt; size_t &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceillumina_1_1interop_1_1logic_1_1utils.html#ae6a10f3c0bf133ada1bbe88d1b025544">actual2expected_map</a> (const std::vector&lt; std::string &gt; &amp;channels)</td></tr>
<tr class="separator:ae6a10f3c0bf133ada1bbe88d1b025544"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2f6e78603d9e8f91275dbcce1c3a7906"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceillumina_1_1interop_1_1logic_1_1utils.html#a2f6e78603d9e8f91275dbcce1c3a7906">update_channel_from_instrument_type</a> (const <a class="el" href="group__constants.html#ga849ace1b7e88812e4c4e2375aec9fff2">constants::instrument_type</a> instrument, std::vector&lt; std::string &gt; &amp;channels)</td></tr>
<tr class="separator:a2f6e78603d9e8f91275dbcce1c3a7906"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0dbe8e500173803e0bc87dd9f7c1ed7b"><td class="memItemLeft" align="right" valign="top">std::vector&lt; std::string &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceillumina_1_1interop_1_1logic_1_1utils.html#a0dbe8e500173803e0bc87dd9f7c1ed7b">update_channel_from_instrument_type</a> (const <a class="el" href="group__constants.html#ga849ace1b7e88812e4c4e2375aec9fff2">constants::instrument_type</a> instrument)</td></tr>
<tr class="separator:a0dbe8e500173803e0bc87dd9f7c1ed7b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae03a48304ed56cc1c9361cf958ab24a5"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__constants.html#ga33317d0a3714d7554ea16619be6dc55c">constants::metric_group</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceillumina_1_1interop_1_1logic_1_1utils.html#ae03a48304ed56cc1c9361cf958ab24a5">to_group</a> (const <a class="el" href="group__constants.html#ga7eb7e5452c2cfdd477b95baae0a1794f">constants::metric_type</a> type)</td></tr>
<tr class="separator:ae03a48304ed56cc1c9361cf958ab24a5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac447906ad98e73e5c30b6ef59194a820"><td class="memItemLeft" align="right" valign="top">const std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceillumina_1_1interop_1_1logic_1_1utils.html#ac447906ad98e73e5c30b6ef59194a820">to_description</a> (const <a class="el" href="group__constants.html#ga7eb7e5452c2cfdd477b95baae0a1794f">constants::metric_type</a> type)</td></tr>
<tr class="separator:ac447906ad98e73e5c30b6ef59194a820"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a72b4951d5e6cba4c1c7a921be3965f9e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceillumina_1_1interop_1_1logic_1_1utils.html#a72b4951d5e6cba4c1c7a921be3965f9e">list_descriptions</a> (std::vector&lt; <a class="el" href="classillumina_1_1interop_1_1constants_1_1enum__description.html">constants::enum_description</a>&lt; <a class="el" href="group__constants.html#ga7eb7e5452c2cfdd477b95baae0a1794f">constants::metric_type</a> &gt; &gt; &amp;types)</td></tr>
<tr class="separator:a72b4951d5e6cba4c1c7a921be3965f9e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acdf272a30e87edee22b4762e69416501"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__constants.html#ga0baaed4aa5bce7891bae38f0695b8903">constants::metric_feature_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceillumina_1_1interop_1_1logic_1_1utils.html#acdf272a30e87edee22b4762e69416501">to_feature</a> (const <a class="el" href="group__constants.html#ga7eb7e5452c2cfdd477b95baae0a1794f">constants::metric_type</a> type)</td></tr>
<tr class="separator:acdf272a30e87edee22b4762e69416501"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6ba9e734ba4c68487b08ee7a49ed3ea0"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__constants.html#ga0baaed4aa5bce7891bae38f0695b8903">constants::metric_feature_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceillumina_1_1interop_1_1logic_1_1utils.html#a6ba9e734ba4c68487b08ee7a49ed3ea0">to_feature</a> (const <a class="el" href="group__constants.html#ga33317d0a3714d7554ea16619be6dc55c">constants::metric_group</a> type)</td></tr>
<tr class="separator:a6ba9e734ba4c68487b08ee7a49ed3ea0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac2be3047947715c7c0ab6ebb5395079b"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceillumina_1_1interop_1_1logic_1_1utils.html#ac2be3047947715c7c0ab6ebb5395079b">is_base_metric</a> (const <a class="el" href="group__constants.html#ga7eb7e5452c2cfdd477b95baae0a1794f">constants::metric_type</a> type)</td></tr>
<tr class="separator:ac2be3047947715c7c0ab6ebb5395079b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae60acf742bcbb793a4100461476382c2"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceillumina_1_1interop_1_1logic_1_1utils.html#ae60acf742bcbb793a4100461476382c2">is_channel_metric</a> (const <a class="el" href="group__constants.html#ga7eb7e5452c2cfdd477b95baae0a1794f">constants::metric_type</a> type)</td></tr>
<tr class="separator:ae60acf742bcbb793a4100461476382c2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9452e643d068379df68ded3f53145fa6"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceillumina_1_1interop_1_1logic_1_1utils.html#a9452e643d068379df68ded3f53145fa6">is_read_metric</a> (const <a class="el" href="group__constants.html#ga7eb7e5452c2cfdd477b95baae0a1794f">constants::metric_type</a> type)</td></tr>
<tr class="separator:a9452e643d068379df68ded3f53145fa6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a29285051a2120525316f2fcf876bf946"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceillumina_1_1interop_1_1logic_1_1utils.html#a29285051a2120525316f2fcf876bf946">is_cycle_metric</a> (const <a class="el" href="group__constants.html#ga7eb7e5452c2cfdd477b95baae0a1794f">constants::metric_type</a> type)</td></tr>
<tr class="separator:a29285051a2120525316f2fcf876bf946"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8dd4c4b2f7d3833a78f78674c3bd3dfd"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceillumina_1_1interop_1_1logic_1_1utils.html#a8dd4c4b2f7d3833a78f78674c3bd3dfd">is_tile_metric</a> (const <a class="el" href="group__constants.html#ga7eb7e5452c2cfdd477b95baae0a1794f">constants::metric_type</a> type)</td></tr>
<tr class="separator:a8dd4c4b2f7d3833a78f78674c3bd3dfd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad4dc7027d6aeb533a5d249300930a0cf"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceillumina_1_1interop_1_1logic_1_1utils.html#ad4dc7027d6aeb533a5d249300930a0cf">list_metrics_to_load</a> (const <a class="el" href="group__constants.html#ga33317d0a3714d7554ea16619be6dc55c">constants::metric_group</a> group, std::vector&lt; unsigned char &gt; &amp;valid_to_load, const <a class="el" href="group__constants.html#ga849ace1b7e88812e4c4e2375aec9fff2">constants::instrument_type</a> instrument=<a class="el" href="group__constants.html#gga849ace1b7e88812e4c4e2375aec9fff2a3769bf76968785b8af8804ed1e749523">constants::NovaSeq</a>)</td></tr>
<tr class="separator:ad4dc7027d6aeb533a5d249300930a0cf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acc1631ee8bd99d945dc8023f8c4fa7a5"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceillumina_1_1interop_1_1logic_1_1utils.html#acc1631ee8bd99d945dc8023f8c4fa7a5">list_metrics_to_load</a> (const <a class="el" href="group__constants.html#ga7eb7e5452c2cfdd477b95baae0a1794f">constants::metric_type</a> type, std::vector&lt; unsigned char &gt; &amp;valid_to_load, const <a class="el" href="group__constants.html#ga849ace1b7e88812e4c4e2375aec9fff2">constants::instrument_type</a> instrument=<a class="el" href="group__constants.html#gga849ace1b7e88812e4c4e2375aec9fff2a3769bf76968785b8af8804ed1e749523">constants::NovaSeq</a>)</td></tr>
<tr class="separator:acc1631ee8bd99d945dc8023f8c4fa7a5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aef7f466f8a195641e081fe4d19c794bf"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceillumina_1_1interop_1_1logic_1_1utils.html#aef7f466f8a195641e081fe4d19c794bf">list_metrics_to_load</a> (const std::vector&lt; <a class="el" href="group__constants.html#ga33317d0a3714d7554ea16619be6dc55c">constants::metric_group</a> &gt; &amp;groups, std::vector&lt; unsigned char &gt; &amp;valid_to_load, const <a class="el" href="group__constants.html#ga849ace1b7e88812e4c4e2375aec9fff2">constants::instrument_type</a> instrument=<a class="el" href="group__constants.html#gga849ace1b7e88812e4c4e2375aec9fff2a3769bf76968785b8af8804ed1e749523">constants::NovaSeq</a>)</td></tr>
<tr class="separator:aef7f466f8a195641e081fe4d19c794bf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6808b91be124c084fb4193da23ecf4f9"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceillumina_1_1interop_1_1logic_1_1utils.html#a6808b91be124c084fb4193da23ecf4f9">list_metrics_to_load</a> (const std::vector&lt; <a class="el" href="group__constants.html#ga7eb7e5452c2cfdd477b95baae0a1794f">constants::metric_type</a> &gt; &amp;types, std::vector&lt; unsigned char &gt; &amp;valid_to_load, const <a class="el" href="group__constants.html#ga849ace1b7e88812e4c4e2375aec9fff2">constants::instrument_type</a> instrument=<a class="el" href="group__constants.html#gga849ace1b7e88812e4c4e2375aec9fff2a3769bf76968785b8af8804ed1e749523">constants::NovaSeq</a>)</td></tr>
<tr class="separator:a6808b91be124c084fb4193da23ecf4f9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa67bda43e69c96d9bbbc0835634eab7f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceillumina_1_1interop_1_1logic_1_1utils.html#aa67bda43e69c96d9bbbc0835634eab7f">list_index_summary_metric_groups</a> (std::vector&lt; <a class="el" href="group__constants.html#ga33317d0a3714d7554ea16619be6dc55c">constants::metric_group</a> &gt; &amp;groups)</td></tr>
<tr class="separator:aa67bda43e69c96d9bbbc0835634eab7f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0d4a5750249dce9ffd136c17684822fe"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceillumina_1_1interop_1_1logic_1_1utils.html#a0d4a5750249dce9ffd136c17684822fe">list_summary_metrics_to_load</a> (std::vector&lt; unsigned char &gt; &amp;valid_to_load, const <a class="el" href="group__constants.html#ga849ace1b7e88812e4c4e2375aec9fff2">constants::instrument_type</a> instrument=<a class="el" href="group__constants.html#gga849ace1b7e88812e4c4e2375aec9fff2a3769bf76968785b8af8804ed1e749523">constants::NovaSeq</a>)</td></tr>
<tr class="separator:a0d4a5750249dce9ffd136c17684822fe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a92145ee3a69aca0a4ffd62671064e22a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceillumina_1_1interop_1_1logic_1_1utils.html#a92145ee3a69aca0a4ffd62671064e22a">list_index_metrics_to_load</a> (std::vector&lt; unsigned char &gt; &amp;valid_to_load)</td></tr>
<tr class="separator:a92145ee3a69aca0a4ffd62671064e22a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad32faf90ea74f8fc6de811c79f4d303b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceillumina_1_1interop_1_1logic_1_1utils.html#ad32faf90ea74f8fc6de811c79f4d303b">list_analysis_metrics_to_load</a> (std::vector&lt; unsigned char &gt; &amp;valid_to_load)</td></tr>
<tr class="separator:ad32faf90ea74f8fc6de811c79f4d303b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5171868ee0a6402a8703e682e7c35ee6"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceillumina_1_1interop_1_1logic_1_1utils.html#a5171868ee0a6402a8703e682e7c35ee6">list_metrics_to_load</a> (const std::string &amp;metric_name, std::vector&lt; unsigned char &gt; &amp;valid_to_load, const <a class="el" href="group__constants.html#ga849ace1b7e88812e4c4e2375aec9fff2">constants::instrument_type</a> instrument)</td></tr>
<tr class="separator:a5171868ee0a6402a8703e682e7c35ee6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a77055bf7bf94e9e7b27f90f45ab4a514"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceillumina_1_1interop_1_1logic_1_1utils.html#a77055bf7bf94e9e7b27f90f45ab4a514">list_summary_metric_groups</a> (std::vector&lt; <a class="el" href="group__constants.html#ga33317d0a3714d7554ea16619be6dc55c">constants::metric_group</a> &gt; &amp;groups, const <a class="el" href="group__constants.html#ga849ace1b7e88812e4c4e2375aec9fff2">constants::instrument_type</a> instrument)</td></tr>
<tr class="separator:a77055bf7bf94e9e7b27f90f45ab4a514"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="var-members"></a>
Variables</h2></td></tr>
<tr class="memitem:a12599a15a252ebdd3beb4262b35b2ad5"><td class="memItemLeft" align="right" valign="top">void <a class="el" href="namespaceillumina_1_1interop_1_1logic_1_1utils.html#ad4dc7027d6aeb533a5d249300930a0cf">list_metrics_to_load</a>(const std::string &amp;metric_name, std::vector&lt; unsigned char &gt; &amp;valid_to_load, const <a class="el" href="group__constants.html#ga849ace1b7e88812e4c4e2375aec9fff2">constants::instrument_type</a> instrument=<a class="el" href="group__constants.html#gga849ace1b7e88812e4c4e2375aec9fff2a3769bf76968785b8af8804ed1e749523">constants::NovaSeq</a>) <a class="el" href="exception__specification_8h.html#aff57a57f70bd067a95a801be66b24b4e">INTEROP_THROW_SPEC</a>((model void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceillumina_1_1interop_1_1logic_1_1utils.html#a12599a15a252ebdd3beb4262b35b2ad5">list_summary_metric_groups</a> (std::vector&lt; <a class="el" href="group__constants.html#ga33317d0a3714d7554ea16619be6dc55c">constants::metric_group</a> &gt; &amp;groups, const <a class="el" href="group__constants.html#ga849ace1b7e88812e4c4e2375aec9fff2">constants::instrument_type</a> instrument=<a class="el" href="group__constants.html#gga849ace1b7e88812e4c4e2375aec9fff2a3769bf76968785b8af8804ed1e749523">constants::NovaSeq</a>)</td></tr>
<tr class="separator:a12599a15a252ebdd3beb4262b35b2ad5"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<h2 class="groupheader">Typedef Documentation</h2>
<a class="anchor" id="ae746ca0acad282c67a43c2dad9abe945"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="classillumina_1_1interop_1_1constants_1_1enum__description.html">constants::enum_description</a>&lt; <a class="el" href="group__constants.html#ga7eb7e5452c2cfdd477b95baae0a1794f">constants::metric_type</a>&gt; <a class="el" href="namespaceillumina_1_1interop_1_1logic_1_1utils.html#ae746ca0acad282c67a43c2dad9abe945">metric_type_description_t</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Define a metric type description </p>

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a class="anchor" id="a6dce24320ac2ef6a132b75fccd331230"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void illumina::interop::logic::utils::actual2expected </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; std::string &gt; &amp;&#160;</td>
          <td class="paramname"><em>channels</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; size_t &gt; &amp;&#160;</td>
          <td class="paramname"><em>map</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Create a mapping of indexes from the actual order to the expected channel order</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">channels</td><td>vector of string channel names </td></tr>
    <tr><td class="paramname">map</td><td>vector of indexes mapping the actual to expected order </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ae6a10f3c0bf133ada1bbe88d1b025544"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;size_t&gt; illumina::interop::logic::utils::actual2expected_map </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; std::string &gt; &amp;&#160;</td>
          <td class="paramname"><em>channels</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Create a mapping of indexes from the actual order to the expected channel order</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">channels</td><td>vector of string channel names </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>vector of indexes mapping the actual to expected order </dd></dl>

</div>
</div>
<a class="anchor" id="a5787505c314cdab120d46405666788eb"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void illumina::interop::logic::utils::expected2actual </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; std::string &gt; &amp;&#160;</td>
          <td class="paramname"><em>channels</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; size_t &gt; &amp;&#160;</td>
          <td class="paramname"><em>map</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Create a mapping of indexes from the expected order to the actual channel order</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">channels</td><td>vector of string channel names </td></tr>
    <tr><td class="paramname">map</td><td>vector of indexes mapping the expected to actual order </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="af69bb7fd7efa2c545746ca29e9b2e6c1"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;size_t&gt; illumina::interop::logic::utils::expected2actual_map </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; std::string &gt; &amp;&#160;</td>
          <td class="paramname"><em>channels</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Create a mapping of indexes from the expected order to the actual channel order</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">channels</td><td>vector of string channel names </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>vector of indexes mapping the expected to actual order </dd></dl>

</div>
</div>
<a class="anchor" id="a50038a8f941214e930c2d42195688bc8"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;std::string&gt; illumina::interop::logic::utils::expected_order </td>
          <td>(</td>
          <td class="paramtype">I&#160;</td>
          <td class="paramname"><em>beg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">I&#160;</td>
          <td class="paramname"><em>end</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Expected channel order</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">beg</td><td>iterator to start of collection </td></tr>
    <tr><td class="paramname">end</td><td>iterator to end of collection </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>string vector of expected channels </dd></dl>

</div>
</div>
<a class="anchor" id="adf2be7941e65e6f65b963742b04348b4"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;std::string&gt; illumina::interop::logic::utils::expected_order </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; std::string &gt; &amp;&#160;</td>
          <td class="paramname"><em>channels</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Expected channel order</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">channels</td><td>vector of string channel names </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>string vector of expected channels </dd></dl>

</div>
</div>
<a class="anchor" id="ac2be3047947715c7c0ab6ebb5395079b"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool illumina::interop::logic::utils::is_base_metric </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="group__constants.html#ga7eb7e5452c2cfdd477b95baae0a1794f">constants::metric_type</a>&#160;</td>
          <td class="paramname"><em>type</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Test if metric type is indexed by DNA base</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">type</td><td>metric type </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if metric can be indexed by DNA base </dd></dl>

</div>
</div>
<a class="anchor" id="ae60acf742bcbb793a4100461476382c2"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool illumina::interop::logic::utils::is_channel_metric </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="group__constants.html#ga7eb7e5452c2cfdd477b95baae0a1794f">constants::metric_type</a>&#160;</td>
          <td class="paramname"><em>type</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Test if metric type is indexed by channel</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">type</td><td>metric type </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if metric can be indexed by channel </dd></dl>

</div>
</div>
<a class="anchor" id="a29285051a2120525316f2fcf876bf946"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool illumina::interop::logic::utils::is_cycle_metric </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="group__constants.html#ga7eb7e5452c2cfdd477b95baae0a1794f">constants::metric_type</a>&#160;</td>
          <td class="paramname"><em>type</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Test if metric type is produced every cycle</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">type</td><td>metric type </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if metric is produced every cycle </dd></dl>

</div>
</div>
<a class="anchor" id="a9452e643d068379df68ded3f53145fa6"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool illumina::interop::logic::utils::is_read_metric </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="group__constants.html#ga7eb7e5452c2cfdd477b95baae0a1794f">constants::metric_type</a>&#160;</td>
          <td class="paramname"><em>type</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Test if metric type is produced every read</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">type</td><td>metric type </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if metric is produced every read </dd></dl>

</div>
</div>
<a class="anchor" id="a8dd4c4b2f7d3833a78f78674c3bd3dfd"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool illumina::interop::logic::utils::is_tile_metric </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="group__constants.html#ga7eb7e5452c2cfdd477b95baae0a1794f">constants::metric_type</a>&#160;</td>
          <td class="paramname"><em>type</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Test if metric type is produced for a tile</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">type</td><td>metric type </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if metric is produced for every tile </dd></dl>

</div>
</div>
<a class="anchor" id="a37db8691e8f774366b2eed13c6d2cc58"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string illumina::interop::logic::utils::join </td>
          <td>(</td>
          <td class="paramtype">I&#160;</td>
          <td class="paramname"><em>beg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">I&#160;</td>
          <td class="paramname"><em>end</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>token</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Join a collection of strings separated by a token into a string</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">beg</td><td>iterator to start of collection </td></tr>
    <tr><td class="paramname">end</td><td>iterator to end of collection </td></tr>
    <tr><td class="paramname">token</td><td>string separator token </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>string of joined values </dd></dl>

</div>
</div>
<a class="anchor" id="a06afc34edd2a54160f0eff8fd897b513"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::string illumina::interop::logic::utils::join </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; std::string &gt; &amp;&#160;</td>
          <td class="paramname"><em>values</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>token</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Join a vector of strings separated by a token into a string</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">values</td><td>vector of strings </td></tr>
    <tr><td class="paramname">token</td><td>string separator token </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>string of joined values </dd></dl>

</div>
</div>
<a class="anchor" id="ad32faf90ea74f8fc6de811c79f4d303b"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void list_analysis_metrics_to_load </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; unsigned char &gt; &amp;&#160;</td>
          <td class="paramname"><em>valid_to_load</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>List all required metric groups for the analysis tab</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">valid_to_load</td><td>list of metrics to load on demand </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a72b4951d5e6cba4c1c7a921be3965f9e"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void illumina::interop::logic::utils::list_descriptions </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; <a class="el" href="classillumina_1_1interop_1_1constants_1_1enum__description.html">constants::enum_description</a>&lt; <a class="el" href="group__constants.html#ga7eb7e5452c2cfdd477b95baae0a1794f">constants::metric_type</a> &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>types</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Convert metric type to string description</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">types</td><td>destination vector of metric types </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a92145ee3a69aca0a4ffd62671064e22a"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void list_index_metrics_to_load </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; unsigned char &gt; &amp;&#160;</td>
          <td class="paramname"><em>valid_to_load</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>List all required metric groups for the index tab</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">valid_to_load</td><td>list of metrics to load on demand</td></tr>
  </table>
  </dd>
</dl>
<p>List all required metric groups</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">valid_to_load</td><td>list of metrics to load on demand </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="aa67bda43e69c96d9bbbc0835634eab7f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void list_index_summary_metric_groups </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; <a class="el" href="group__constants.html#ga33317d0a3714d7554ea16619be6dc55c">constants::metric_group</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>groups</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>List all required metric groups</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">groups</td><td>destination group list </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ad4dc7027d6aeb533a5d249300930a0cf"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void list_metrics_to_load </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="group__constants.html#ga33317d0a3714d7554ea16619be6dc55c">constants::metric_group</a>&#160;</td>
          <td class="paramname"><em>group</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; unsigned char &gt; &amp;&#160;</td>
          <td class="paramname"><em>valid_to_load</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="group__constants.html#ga849ace1b7e88812e4c4e2375aec9fff2">constants::instrument_type</a>&#160;</td>
          <td class="paramname"><em>instrument</em> = <code><a class="el" href="group__constants.html#gga849ace1b7e88812e4c4e2375aec9fff2a3769bf76968785b8af8804ed1e749523">constants::NovaSeq</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>List the required on demand metrics</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">group</td><td>specific metric group to load </td></tr>
    <tr><td class="paramname">valid_to_load</td><td>list of metrics to load on demand </td></tr>
    <tr><td class="paramname">instrument</td><td>instrument type </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="acc1631ee8bd99d945dc8023f8c4fa7a5"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void list_metrics_to_load </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="group__constants.html#ga7eb7e5452c2cfdd477b95baae0a1794f">constants::metric_type</a>&#160;</td>
          <td class="paramname"><em>type</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; unsigned char &gt; &amp;&#160;</td>
          <td class="paramname"><em>valid_to_load</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="group__constants.html#ga849ace1b7e88812e4c4e2375aec9fff2">constants::instrument_type</a>&#160;</td>
          <td class="paramname"><em>instrument</em> = <code><a class="el" href="group__constants.html#gga849ace1b7e88812e4c4e2375aec9fff2a3769bf76968785b8af8804ed1e749523">constants::NovaSeq</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>List the required on demand metrics</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">type</td><td>specific metric type to load </td></tr>
    <tr><td class="paramname">valid_to_load</td><td>list of metrics to load on demand </td></tr>
    <tr><td class="paramname">instrument</td><td>instrument type </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="aef7f466f8a195641e081fe4d19c794bf"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void list_metrics_to_load </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="group__constants.html#ga33317d0a3714d7554ea16619be6dc55c">constants::metric_group</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>groups</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; unsigned char &gt; &amp;&#160;</td>
          <td class="paramname"><em>valid_to_load</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="group__constants.html#ga849ace1b7e88812e4c4e2375aec9fff2">constants::instrument_type</a>&#160;</td>
          <td class="paramname"><em>instrument</em> = <code><a class="el" href="group__constants.html#gga849ace1b7e88812e4c4e2375aec9fff2a3769bf76968785b8af8804ed1e749523">constants::NovaSeq</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>List the required on demand metrics</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">groups</td><td>collection of specific metric groups to load </td></tr>
    <tr><td class="paramname">valid_to_load</td><td>list of metrics to load on demand </td></tr>
    <tr><td class="paramname">instrument</td><td>instrument type </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a6808b91be124c084fb4193da23ecf4f9"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void list_metrics_to_load </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="group__constants.html#ga7eb7e5452c2cfdd477b95baae0a1794f">constants::metric_type</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>types</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; unsigned char &gt; &amp;&#160;</td>
          <td class="paramname"><em>valid_to_load</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="group__constants.html#ga849ace1b7e88812e4c4e2375aec9fff2">constants::instrument_type</a>&#160;</td>
          <td class="paramname"><em>instrument</em> = <code><a class="el" href="group__constants.html#gga849ace1b7e88812e4c4e2375aec9fff2a3769bf76968785b8af8804ed1e749523">constants::NovaSeq</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>List the required on demand metrics</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">types</td><td>collection of specific metric types to load </td></tr>
    <tr><td class="paramname">valid_to_load</td><td>list of metrics to load on demand </td></tr>
    <tr><td class="paramname">instrument</td><td>instrument type </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a5171868ee0a6402a8703e682e7c35ee6"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void illumina::interop::logic::utils::list_metrics_to_load </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>metric_name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; unsigned char &gt; &amp;&#160;</td>
          <td class="paramname"><em>valid_to_load</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="group__constants.html#ga849ace1b7e88812e4c4e2375aec9fff2">constants::instrument_type</a>&#160;</td>
          <td class="paramname"><em>instrument</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>List the required on demand metrics</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">metric_name</td><td>name of metric value to load </td></tr>
    <tr><td class="paramname">valid_to_load</td><td>list of metrics to load on demand </td></tr>
    <tr><td class="paramname">instrument</td><td>instrument type </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a77055bf7bf94e9e7b27f90f45ab4a514"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void illumina::interop::logic::utils::list_summary_metric_groups </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; <a class="el" href="group__constants.html#ga33317d0a3714d7554ea16619be6dc55c">constants::metric_group</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>groups</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="group__constants.html#ga849ace1b7e88812e4c4e2375aec9fff2">constants::instrument_type</a>&#160;</td>
          <td class="paramname"><em>instrument</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>List all required metric groups</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">groups</td><td>destination group list </td></tr>
    <tr><td class="paramname">instrument</td><td>instrument type </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a0d4a5750249dce9ffd136c17684822fe"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void list_summary_metrics_to_load </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; unsigned char &gt; &amp;&#160;</td>
          <td class="paramname"><em>valid_to_load</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="group__constants.html#ga849ace1b7e88812e4c4e2375aec9fff2">constants::instrument_type</a>&#160;</td>
          <td class="paramname"><em>instrument</em> = <code><a class="el" href="group__constants.html#gga849ace1b7e88812e4c4e2375aec9fff2a3769bf76968785b8af8804ed1e749523">constants::NovaSeq</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>List all required metric groups for the summary tab</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">valid_to_load</td><td>list of metrics to load on demand </td></tr>
    <tr><td class="paramname">instrument</td><td>instrument type</td></tr>
  </table>
  </dd>
</dl>
<p>List all required metric groups</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">valid_to_load</td><td>list of metrics to load on demand </td></tr>
    <tr><td class="paramname">instrument</td><td>instrument type </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a83f9d5e6ba2e0d2e0104334f70d32b46"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::string illumina::interop::logic::utils::normalize </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>channel</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Normalize a channel name by making it lower case</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">channel</td><td>channel name </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>lowercase channel name </dd></dl>

</div>
</div>
<a class="anchor" id="a6122d6ca92696f10f3863296cc74e9c1"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void illumina::interop::logic::utils::normalize </td>
          <td>(</td>
          <td class="paramtype">I&#160;</td>
          <td class="paramname"><em>beg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">I&#160;</td>
          <td class="paramname"><em>end</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">O&#160;</td>
          <td class="paramname"><em>out</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Normalize a collection of channel names</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">beg</td><td>iterator to start of collection </td></tr>
    <tr><td class="paramname">end</td><td>iterator to end of collection </td></tr>
    <tr><td class="paramname">out</td><td>output iterator </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ac447906ad98e73e5c30b6ef59194a820"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const std::string illumina::interop::logic::utils::to_description </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="group__constants.html#ga7eb7e5452c2cfdd477b95baae0a1794f">constants::metric_type</a>&#160;</td>
          <td class="paramname"><em>type</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Convert metric type to string description</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">type</td><td>metric type </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>string description </dd></dl>

</div>
</div>
<a class="anchor" id="acdf272a30e87edee22b4762e69416501"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__constants.html#ga0baaed4aa5bce7891bae38f0695b8903">constants::metric_feature_type</a> illumina::interop::logic::utils::to_feature </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="group__constants.html#ga7eb7e5452c2cfdd477b95baae0a1794f">constants::metric_type</a>&#160;</td>
          <td class="paramname"><em>type</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Convert metric type to metric feature type</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">type</td><td>metric type </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>metric feature type </dd></dl>

</div>
</div>
<a class="anchor" id="a6ba9e734ba4c68487b08ee7a49ed3ea0"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__constants.html#ga0baaed4aa5bce7891bae38f0695b8903">constants::metric_feature_type</a> illumina::interop::logic::utils::to_feature </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="group__constants.html#ga33317d0a3714d7554ea16619be6dc55c">constants::metric_group</a>&#160;</td>
          <td class="paramname"><em>type</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Convert group type to metric feature type</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">type</td><td>group type </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>metric feature type </dd></dl>

</div>
</div>
<a class="anchor" id="ae03a48304ed56cc1c9361cf958ab24a5"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__constants.html#ga33317d0a3714d7554ea16619be6dc55c">constants::metric_group</a> illumina::interop::logic::utils::to_group </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="group__constants.html#ga7eb7e5452c2cfdd477b95baae0a1794f">constants::metric_type</a>&#160;</td>
          <td class="paramname"><em>type</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Convert metric type to metric group</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">type</td><td>metric type </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>metric group </dd></dl>

</div>
</div>
<a class="anchor" id="a2f6e78603d9e8f91275dbcce1c3a7906"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void illumina::interop::logic::utils::update_channel_from_instrument_type </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="group__constants.html#ga849ace1b7e88812e4c4e2375aec9fff2">constants::instrument_type</a>&#160;</td>
          <td class="paramname"><em>instrument</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; std::string &gt; &amp;&#160;</td>
          <td class="paramname"><em>channels</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Update channels from instrument type</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">instrument</td><td>enum type of instrument </td></tr>
    <tr><td class="paramname">channels</td><td>destination vector for channels </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a0dbe8e500173803e0bc87dd9f7c1ed7b"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;std::string&gt; illumina::interop::logic::utils::update_channel_from_instrument_type </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="group__constants.html#ga849ace1b7e88812e4c4e2375aec9fff2">constants::instrument_type</a>&#160;</td>
          <td class="paramname"><em>instrument</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Update channels from instrument type</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">instrument</td><td>enum type of instrument </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>vector of channel names </dd></dl>

</div>
</div>
<h2 class="groupheader">Variable Documentation</h2>
<a class="anchor" id="a12599a15a252ebdd3beb4262b35b2ad5"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="namespaceillumina_1_1interop_1_1logic_1_1utils.html#ad4dc7027d6aeb533a5d249300930a0cf">list_metrics_to_load</a> (const std::string&amp; metric_name, std::vector&lt;unsigned char&gt;&amp; valid_to_load, const <a class="el" href="group__constants.html#ga849ace1b7e88812e4c4e2375aec9fff2">constants::instrument_type</a> instrument=<a class="el" href="group__constants.html#gga849ace1b7e88812e4c4e2375aec9fff2a3769bf76968785b8af8804ed1e749523">constants::NovaSeq</a>) <a class="el" href="exception__specification_8h.html#aff57a57f70bd067a95a801be66b24b4e">INTEROP_THROW_SPEC</a>((model void list_summary_metric_groups(std::vector&lt; <a class="el" href="group__constants.html#ga33317d0a3714d7554ea16619be6dc55c">constants::metric_group</a> &gt; &amp;groups, const <a class="el" href="group__constants.html#ga849ace1b7e88812e4c4e2375aec9fff2">constants::instrument_type</a> instrument=<a class="el" href="group__constants.html#gga849ace1b7e88812e4c4e2375aec9fff2a3769bf76968785b8af8804ed1e749523">constants::NovaSeq</a>)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>List the required on demand metrics</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">metric_name</td><td>name of metric value to load </td></tr>
    <tr><td class="paramname">valid_to_load</td><td>list of metrics to load on demand </td></tr>
    <tr><td class="paramname">instrument</td><td>instrument type List all required metric groups</td></tr>
    <tr><td class="paramname">groups</td><td>destination group list </td></tr>
    <tr><td class="paramname">instrument</td><td>instrument type </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
</div><!-- contents -->
<!-- HTML footer for doxygen 1.8.10-->
<!-- start footer part -->
<hr class="footer"/>
</body>
</html>
