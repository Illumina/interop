<!-- HTML header for doxygen 1.8.8-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
 <meta http-equiv="X-UA-Compatible" content="IE=edge">
 <!-- For Mobile Devices -->
 <meta name="viewport" content="width=device-width, initial-scale=1">
 <!-- Loading Lato Font -->
 <link href='https://fonts.googleapis.com/css?family=Lato:300,400,700,300italic,400italic,700italic' rel='stylesheet' type='text/css'>
 <!-- Loading Font Awesome -->
 <link rel="stylesheet" href="https://maxcdn.bootstrapcdn.com/font-awesome/4.3.0/css/font-awesome.min.css">
 <meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
 <meta name="generator" content="Doxygen 1.8.10"/>
 <script type="text/javascript" src="https://code.jquery.com/jquery-2.1.1.min.js"></script>
 <script>
  (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
  (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
  m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
  })(window,document,'script','https://www.google-analytics.com/analytics.js','ga');
  ga('create', 'UA-88338608-1', 'auto');
  ga('send', 'pageview');
</script>
 <title>core Namespace Reference</title>
 <!--<link href="tabs.css" rel="stylesheet" type="text/css"/>-->
 <script type="text/javascript" src="dynsections.js"></script>
 <link href="doxygen.css" rel="stylesheet" type="text/css" />
 <link href="customdoxygen.css" rel="stylesheet" type="text/css" />
 <link rel="stylesheet" href="bootstrap3/css/bootstrap.min.css">
 <link href="bootstrap3/css/sticky-footer-navbar.css" rel="stylesheet">
 <script src="bootstrap3/js/bootstrap.min.js"></script>
 <script type="text/javascript" src="doxy-boot.js"></script>
</head>
<body screen_capture_injected="true">
<nav class="navbar navbar-inverse" role="navigation">
 <div class="container">
  <div class="navbar-header">
   <a class="navbar-brand" href="https://www.illumina.com/"><img style='margin-top: -8px !important;height: 40px !important;' src='ILLUMINA_LOGO_RGB_new_200_45.png' /></a>
   <a class="navbar-brand">InterOp <span style="font-size: 10pt">v1.2.0</span>  </a>
  </div>
  <div class="collapse navbar-collapse">
   <!-- Left -->
   <ul class="nav navbar-nav adjust-right">
    <li><a href="https://github.com/Illumina/interop">Code</a></li>
    <li><a href="https://github.com/Illumina/interop/issues">Issues</a></li>
    <li><a href="https://github.com/Illumina/interop/releases/latest">Download</a></li>
   </ul>
  </div><!--/.nav-collapse -->
 </div>
</nav>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
 <div class="content" id="content">
  <div class="container">
   <div class="row">
    <div class="col-sm-12 panel panel-default" style="padding-bottom: 15px;">
     <div style="margin-bottom: 15px;">
      <!-- end header part -->
<!-- Generated by Doxygen 1.8.10 -->
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Home</span></a></li>
      <li><a href="pages.html"><span>Index</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="namespacemembers.html"><span>Namespace&#160;Members</span></a></li>
    </ul>
  </div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#func-members">Functions</a> &#124;
<a href="#var-members">Variables</a>  </div>
  <div class="headertitle">
<div class="title">core Namespace Reference</div>  </div>
</div><!--header-->
<div class="contents">
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:aa2d77c36f24e55d0d9f31de38e9cb55e"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecore.html#aa2d77c36f24e55d0d9f31de38e9cb55e">index_summary</a> (run_metrics, level='Lane', columns=None, dtype='f4', extra)</td></tr>
<tr class="separator:aa2d77c36f24e55d0d9f31de38e9cb55e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0491c7a5e13b732447a6ba17fb6150b2"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecore.html#a0491c7a5e13b732447a6ba17fb6150b2">index_summary_columns</a></td></tr>
<tr class="separator:a0491c7a5e13b732447a6ba17fb6150b2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7299ac8ed2d54e8738cbd72c3fc6b3e8"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecore.html#a7299ac8ed2d54e8738cbd72c3fc6b3e8">summary</a> (run_metrics, level='Total', columns=None, dtype='f4', ignore_missing_columns=True, extra)</td></tr>
<tr class="separator:a7299ac8ed2d54e8738cbd72c3fc6b3e8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a596ca1683cb46d9ec6759c95c3dd5ccc"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecore.html#a596ca1683cb46d9ec6759c95c3dd5ccc">load_summary_metrics</a> ()</td></tr>
<tr class="separator:a596ca1683cb46d9ec6759c95c3dd5ccc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a56bf215828f129b8251ddfcb17b6612a"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecore.html#a56bf215828f129b8251ddfcb17b6612a">summary_columns</a></td></tr>
<tr class="separator:a56bf215828f129b8251ddfcb17b6612a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab2c33eaddb2b6296a8a175cf70316324"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecore.html#ab2c33eaddb2b6296a8a175cf70316324">indexing</a> (run_metrics, per_sample=True, dtype='f4', stype='O', extra)</td></tr>
<tr class="separator:ab2c33eaddb2b6296a8a175cf70316324"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab181cd004c7d8d415c5fb0b5a50f3dac"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecore.html#ab181cd004c7d8d415c5fb0b5a50f3dac">imaging</a> (run_metrics, dtype='f4', extra)</td></tr>
<tr class="separator:ab181cd004c7d8d415c5fb0b5a50f3dac"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adf94f477c2741f95442069950614ac76"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecore.html#adf94f477c2741f95442069950614ac76">imaging_columns</a> (run_metrics, extra)</td></tr>
<tr class="separator:adf94f477c2741f95442069950614ac76"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac87c7fef8f2bf170c4e08f70cfce2787"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecore.html#ac87c7fef8f2bf170c4e08f70cfce2787">read</a> (run, valid_to_load=None, requires=None, search_paths=None, extra)</td></tr>
<tr class="separator:ac87c7fef8f2bf170c4e08f70cfce2787"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4f27776530b4094e088007839a2ca548"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecore.html#a4f27776530b4094e088007839a2ca548">read_metric</a></td></tr>
<tr class="separator:a4f27776530b4094e088007839a2ca548"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaa15e7951258b4fb4c55f8bb72e5a09f"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecore.html#aaa15e7951258b4fb4c55f8bb72e5a09f">create_valid_to_load</a> (interop_prefixes)</td></tr>
<tr class="separator:aaa15e7951258b4fb4c55f8bb72e5a09f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a977dd46aa2a288df717cf34df56bd357"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecore.html#a977dd46aa2a288df717cf34df56bd357">enable_metrics</a> (valid_to_load, interop_prefixes)</td></tr>
<tr class="separator:a977dd46aa2a288df717cf34df56bd357"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a99bcd29dfabd7b48ed2b4fce7740bd05"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecore.html#a99bcd29dfabd7b48ed2b4fce7740bd05">load_to_string_list</a> (valid_to_load)</td></tr>
<tr class="separator:a99bcd29dfabd7b48ed2b4fce7740bd05"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9ce166e55d5300bb756b0a7332d847a1"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecore.html#a9ce166e55d5300bb756b0a7332d847a1">group_from_filename</a> (filename)</td></tr>
<tr class="separator:a9ce166e55d5300bb756b0a7332d847a1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4637a8261f8dbd40cf86dacfe13499c6"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecore.html#a4637a8261f8dbd40cf86dacfe13499c6">load_imaging_metrics</a> ()</td></tr>
<tr class="separator:a4637a8261f8dbd40cf86dacfe13499c6"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="var-members"></a>
Variables</h2></td></tr>
<tr class="memitem:a38d15b47e551e4a1748077708683f034"><td class="memItemLeft" align="right" valign="top">tuple&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecore.html#a38d15b47e551e4a1748077708683f034">_summary_levels</a> = ('Total', 'NonIndex', 'Read', 'Lane', 'Surface')</td></tr>
<tr class="separator:a38d15b47e551e4a1748077708683f034"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4135f6454013242755ca4f40b0154e36"><td class="memItemLeft" align="right" valign="top">tuple&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecore.html#a4135f6454013242755ca4f40b0154e36">_index_summary_levels</a> = ('Lane', 'Barcode')</td></tr>
<tr class="separator:a4135f6454013242755ca4f40b0154e36"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><pre class="fragment">@package interop         {#interop_core}
Core routines to simplify using the InterOp Library

InterOp is built around a single data structure alled a `run_metrics` object. This contains the full set of InterOps
along with the RunInfo.xml and some of the RunParameters.xml.

A run metrics object can be read in as follows:
&gt;&gt;&gt; from interop import read
&gt;&gt;&gt; run_metrics = read("some/path/run_folder_name") # doctest: +SKIP

Core routines take the run_metrics object and convert it into a table represented by a structured NumPy array. This can,
in turn, be converted to a pandas DataFrame or any other data structure.

The core routines include the following:

&gt;&gt;&gt; from interop import index_summary
&gt;&gt;&gt; index_summary(run_metrics_with_indexing)
array([(1, 0.4556, 1015.5555, 520.6667, 1536.2222, 1800., 2000.)],
  dtype=[('Lane', '&lt;u2'), ('Mapped Reads Cv', '&lt;f4'), ('Max Mapped Reads', '&lt;f4'), ('Min Mapped Reads', '&lt;f4'), ('Total Fraction Mapped Reads', '&lt;f4'), ('Total Pf Reads', '&lt;f4'), ('Total Reads', '&lt;f4')])

&gt;&gt;&gt; from interop import summary
&gt;&gt;&gt; summary(run_metrics_example)
array([(0.36666667, 6.6666665, 0., 0., 0.)],
  dtype=[('Error Rate', '&lt;f4'), ('First Cycle Intensity', '&lt;f4'), ('Projected Yield G', '&lt;f4'), ('Reads', '&lt;f4'), ('Reads Pf', '&lt;f4')])

&gt;&gt;&gt; from interop import indexing
&gt;&gt;&gt; indexing(run_metrics_with_indexing)
array([(1., 1101., 'ATCACGAC-AAGGTTCA', '1', 4570., 900., 507.77777),
   (1., 1101., 'ATCACGAC-GGGGGGGG', '2', 2343., 900., 260.33334),
   (1., 1102., 'ATCACGAC-AAGGTTCA', '1', 4570.,   0.,   0.     ),
   (1., 1102., 'ATCACGAC-GGGGGGGG', '2', 2343.,   0.,   0.     )],
  dtype=[('Lane', '&lt;f4'), ('Tile', '&lt;f4'), ('Barcode', 'O'), ('SampleID', 'O'), ('Cluster Count', '&lt;f4'), ('Cluster Count PF', '&lt;f4'), ('% Demux', '&lt;f4')])

&gt;&gt;&gt; from interop import imaging
&gt;&gt;&gt; imaging(run_metrics_example)
rec.array([(1., 1101., 1., 1., 1., 0.1, 10., 10., 25. , 33.3, 33.3, 33.3, 0., 10., 10., nan, nan, nan, nan, nan, nan, nan, nan, nan, 1., 1., 1.),
       (1., 1101., 2., 1., 2., 0.2,  5., 15., 12.5, 42.9, 28.6, 28.6, 0.,  5., 15., nan, nan, nan, nan, nan, nan, nan, nan, nan, 1., 1., 1.),
       (1., 1101., 3., 1., 3., 0.3, 10., 10., 25. , 33.3, 50. , 16.7, 0., 10., 10., nan, nan, nan, nan, nan, nan, nan, nan, nan, 1., 1., 1.),
       (1., 1101., 4., 2., 1., 0.4, 10.,  5., 25. , 16.7, 50. , 33.3, 0., 10.,  5., nan, nan, nan, nan, nan, nan, nan, nan, nan, 1., 1., 1.),
       (1., 1101., 5., 3., 1., 0.5, 15.,  5., 37.5, 20. , 40. , 40. , 0., 15.,  5., nan, nan, nan, nan, nan, nan, nan, nan, nan, 1., 1., 1.)],
      dtype=[('Lane', '&lt;f4'), ('Tile', '&lt;f4'), ('Cycle', '&lt;f4'), ('Read', '&lt;f4'), ('Cycle Within Read', '&lt;f4'), ('Error Rate', '&lt;f4'), ('P90/green', '&lt;f4'), ('P90/blue', '&lt;f4'), ('% No Calls', '&lt;f4'), ('% Base/A', '&lt;f4'), ('% Base/C', '&lt;f4'), ('% Base/G', '&lt;f4'), ('% Base/T', '&lt;f4'), ('Fwhm/green', '&lt;f4'), ('Fwhm/blue', '&lt;f4'), ('Corrected/A', '&lt;f4'), ('Corrected/C', '&lt;f4'), ('Corrected/G', '&lt;f4'), ('Corrected/T', '&lt;f4'), ('Called/A', '&lt;f4'), ('Called/C', '&lt;f4'), ('Called/G', '&lt;f4'), ('Called/T', '&lt;f4'), ('Signal To Noise', '&lt;f4'), ('Surface', '&lt;f4'), ('Swath', '&lt;f4'), ('Tile Number', '&lt;f4')])

Any of the core routines above can take a `run_metrics` object or a string containing a file path to a valid run folder.

&gt;&gt;&gt; ar = index_summary("some/path/run_folder_name") # doctest: +SKIP

The structured NumPy array can be converted to a Pandas DataFrame just so:

&gt;&gt;&gt; import pandas as pd # doctest: +SKIP
&gt;&gt;&gt; df = pd.DataFrame(ar) # doctest: +SKIP

For more information see the documentation around each function below.
</pre> </div><h2 class="groupheader">Function Documentation</h2>
<a class="anchor" id="aaa15e7951258b4fb4c55f8bb72e5a09f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def core.create_valid_to_load </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>interop_prefixes</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Create list of metrics valid to load by the InterOp library

List of validate metric_names can be gotten using `list_interop_files`

&gt;&gt;&gt; from interop import create_valid_to_load
&gt;&gt;&gt; int(create_valid_to_load(['Extraction'])[0])
0
&gt;&gt;&gt; create_valid_to_load(0)
Traceback (most recent call last):
    ...
TypeError: Parameter valid_to_load must be a collection of values

:param interop_prefixes: list of strings containing InterOp metric names
:return: py_interop_run.uchar_vector
</pre> 
</div>
</div>
<a class="anchor" id="a977dd46aa2a288df717cf34df56bd357"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def core.enable_metrics </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>valid_to_load</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>interop_prefixes</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Enable metrics in valid_to_load

&gt;&gt;&gt; from interop import enable_metrics, load_to_string_list
&gt;&gt;&gt; import interop.py_interop_run as interop_run
&gt;&gt;&gt; valid_to_load = interop_run.uchar_vector(interop_run.MetricCount, 0)
&gt;&gt;&gt; load_to_string_list(enable_metrics(valid_to_load, 'Extraction'))
['Extraction']
&gt;&gt;&gt; load_to_string_list(enable_metrics(valid_to_load, ['Error', 'Q']))
['Error', 'Extraction', 'Q']

Nothing changes when passing in an empty list
&gt;&gt;&gt; load_to_string_list(enable_metrics(valid_to_load, []))
['Error', 'Extraction', 'Q']

Here are some example exceptions when the improper parameter is given

&gt;&gt;&gt; enable_metrics(valid_to_load, None)
Traceback (most recent call last):
  ...
TypeError: 'NoneType' object is not iterable
&gt;&gt;&gt; enable_metrics(None, [])
Traceback (most recent call last):
...
TypeError: Parameter valid_to_load must be of type interop.py_interop_run.uchar_vector
&gt;&gt;&gt; enable_metrics("None", [])
Traceback (most recent call last):
...
TypeError: Parameter valid_to_load must be of type interop.py_interop_run.uchar_vector


:param valid_to_load: interop_run.uchar_vector (boolean array)
:param interop_prefixes: list of metrics to enable
:return: interop_run.uchar_vector (It is updated in-place so the return can be ignored)
</pre> 
</div>
</div>
<a class="anchor" id="a9ce166e55d5300bb756b0a7332d847a1"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def core.group_from_filename </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>filename</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Get the metric group id from an InterOp filename path

&gt;&gt;&gt; from interop import group_from_filename
&gt;&gt;&gt; import interop.py_interop_run as interop_run
&gt;&gt;&gt; group_from_filename("some/path/run/InterOp/ExtractionMetricsOut.bin")
2
&gt;&gt;&gt; interop_run.Extraction
2

This group id can be used to load a metric from a binary buffer as in `interop.core.read_metric`

:param filename: path to interop metric
:return: interop_run.metric_group
</pre> 
</div>
</div>
<a class="anchor" id="ab181cd004c7d8d415c5fb0b5a50f3dac"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def core.imaging </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>run_metrics</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>dtype</em> = <code>'f4'</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>extra</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Convert InterOp run_metrics (or read run_metrics from disk) to a numpy structured array containing the imaging
table

We can read an imaging table directly from a run folder. Note, this does not load all metrics, only those required
by the imaging table. See `load_imaging_metrics` for that list.

Also note that loading only tile level metrics (e.g. metrics without cycles) will result in an empty table. This is
a limitation of the imaging table.

&gt;&gt;&gt; from interop import imaging
&gt;&gt;&gt; from interop import load_imaging_metrics
&gt;&gt;&gt; import interop.py_interop_run_metrics as interop_metrics
&gt;&gt;&gt; import numpy as np
&gt;&gt;&gt; ar = imaging("some/path/run_folder_name") # doctest: +SKIP

The above function is equivalent to
&gt;&gt;&gt; ar = imaging("some/path/run_folder_name", valid_to_load=load_imaging_metrics()) # doctest: +SKIP

We can select a subset of metrics to include based on metric groups
&gt;&gt;&gt; ar = imaging("some/path/run_folder_name", valid_to_load=['Error']) # doctest: +SKIP

See `read` below for more examples.

The following example will rely on an existing run_metrics object (possibly created by the `read` function below).

&gt;&gt;&gt; ar = imaging(run_metrics_example)
&gt;&gt;&gt; ar
rec.array([(1., 1101., 1., 1., 1., 0.1, 10., 10., 25. , 33.3, 33.3, 33.3, 0., 10., 10., nan, nan, nan, nan, nan, nan, nan, nan, nan, 1., 1., 1.),
           (1., 1101., 2., 1., 2., 0.2,  5., 15., 12.5, 42.9, 28.6, 28.6, 0.,  5., 15., nan, nan, nan, nan, nan, nan, nan, nan, nan, 1., 1., 1.),
           (1., 1101., 3., 1., 3., 0.3, 10., 10., 25. , 33.3, 50. , 16.7, 0., 10., 10., nan, nan, nan, nan, nan, nan, nan, nan, nan, 1., 1., 1.),
           (1., 1101., 4., 2., 1., 0.4, 10.,  5., 25. , 16.7, 50. , 33.3, 0., 10.,  5., nan, nan, nan, nan, nan, nan, nan, nan, nan, 1., 1., 1.),
           (1., 1101., 5., 3., 1., 0.5, 15.,  5., 37.5, 20. , 40. , 40. , 0., 15.,  5., nan, nan, nan, nan, nan, nan, nan, nan, nan, 1., 1., 1.)],
          dtype=[('Lane', '&lt;f4'), ('Tile', '&lt;f4'), ('Cycle', '&lt;f4'), ('Read', '&lt;f4'), ('Cycle Within Read', '&lt;f4'), ('Error Rate', '&lt;f4'), ('P90/green', '&lt;f4'), ('P90/blue', '&lt;f4'), ('% No Calls', '&lt;f4'), ('% Base/A', '&lt;f4'), ('% Base/C', '&lt;f4'), ('% Base/G', '&lt;f4'), ('% Base/T', '&lt;f4'), ('Fwhm/green', '&lt;f4'), ('Fwhm/blue', '&lt;f4'), ('Corrected/A', '&lt;f4'), ('Corrected/C', '&lt;f4'), ('Corrected/G', '&lt;f4'), ('Corrected/T', '&lt;f4'), ('Called/A', '&lt;f4'), ('Called/C', '&lt;f4'), ('Called/G', '&lt;f4'), ('Called/T', '&lt;f4'), ('Signal To Noise', '&lt;f4'), ('Surface', '&lt;f4'), ('Swath', '&lt;f4'), ('Tile Number', '&lt;f4')])

&gt;&gt;&gt; ar.dtype
dtype((numpy.record, [('Lane', '&lt;f4'), ('Tile', '&lt;f4'), ('Cycle', '&lt;f4'), ('Read', '&lt;f4'), ('Cycle Within Read', '&lt;f4'), ('Error Rate', '&lt;f4'), ('P90/green', '&lt;f4'), ('P90/blue', '&lt;f4'), ('% No Calls', '&lt;f4'), ('% Base/A', '&lt;f4'), ('% Base/C', '&lt;f4'), ('% Base/G', '&lt;f4'), ('% Base/T', '&lt;f4'), ('Fwhm/green', '&lt;f4'), ('Fwhm/blue', '&lt;f4'), ('Corrected/A', '&lt;f4'), ('Corrected/C', '&lt;f4'), ('Corrected/G', '&lt;f4'), ('Corrected/T', '&lt;f4'), ('Called/A', '&lt;f4'), ('Called/C', '&lt;f4'), ('Called/G', '&lt;f4'), ('Called/T', '&lt;f4'), ('Signal To Noise', '&lt;f4'), ('Surface', '&lt;f4'), ('Swath', '&lt;f4'), ('Tile Number', '&lt;f4')]))

We can convert the numpy array to a Pandas DataFrame as follows:

&gt;&gt;&gt; import pandas as pd  # doctest: +SKIP
&gt;&gt;&gt; df = pd.DataFrame(ar)  # doctest: +SKIP
&gt;&gt;&gt; df  # doctest: +SKIP
   Lane  ...  Tile Number
0   1.0  ...          1.0
1   1.0  ...          1.0
2   1.0  ...          1.0
3   1.0  ...          1.0
4   1.0  ...          1.0
&lt;BLANKLINE&gt;
[5 rows x 27 columns]

You can also change the dtype of the resulting data array table.
&gt;&gt;&gt; imaging(run_metrics_example, dtype=np.float32)
rec.array([(1., 1101., 1., 1., 1., 0.1, 10., 10., 25. , 33.3, 33.3, 33.3, 0., 10., 10., nan, nan, nan, nan, nan, nan, nan, nan, nan, 1., 1., 1.),
           (1., 1101., 2., 1., 2., 0.2,  5., 15., 12.5, 42.9, 28.6, 28.6, 0.,  5., 15., nan, nan, nan, nan, nan, nan, nan, nan, nan, 1., 1., 1.),
           (1., 1101., 3., 1., 3., 0.3, 10., 10., 25. , 33.3, 50. , 16.7, 0., 10., 10., nan, nan, nan, nan, nan, nan, nan, nan, nan, 1., 1., 1.),
           (1., 1101., 4., 2., 1., 0.4, 10.,  5., 25. , 16.7, 50. , 33.3, 0., 10.,  5., nan, nan, nan, nan, nan, nan, nan, nan, nan, 1., 1., 1.),
           (1., 1101., 5., 3., 1., 0.5, 15.,  5., 37.5, 20. , 40. , 40. , 0., 15.,  5., nan, nan, nan, nan, nan, nan, nan, nan, nan, 1., 1., 1.)],
          dtype=[('Lane', '&lt;f4'), ('Tile', '&lt;f4'), ('Cycle', '&lt;f4'), ('Read', '&lt;f4'), ('Cycle Within Read', '&lt;f4'), ('Error Rate', '&lt;f4'), ('P90/green', '&lt;f4'), ('P90/blue', '&lt;f4'), ('% No Calls', '&lt;f4'), ('% Base/A', '&lt;f4'), ('% Base/C', '&lt;f4'), ('% Base/G', '&lt;f4'), ('% Base/T', '&lt;f4'), ('Fwhm/green', '&lt;f4'), ('Fwhm/blue', '&lt;f4'), ('Corrected/A', '&lt;f4'), ('Corrected/C', '&lt;f4'), ('Corrected/G', '&lt;f4'), ('Corrected/T', '&lt;f4'), ('Called/A', '&lt;f4'), ('Called/C', '&lt;f4'), ('Called/G', '&lt;f4'), ('Called/T', '&lt;f4'), ('Signal To Noise', '&lt;f4'), ('Surface', '&lt;f4'), ('Swath', '&lt;f4'), ('Tile Number', '&lt;f4')])

Here is the output if an empty run_metrics was provided
&gt;&gt;&gt; imaging(interop_metrics.run_metrics())
array([], dtype=float64)

Here is an example exception if an improper input is given
&gt;&gt;&gt; imaging(None)
Traceback (most recent call last):
...
ValueError: Expected interop.py_interop_run_metrics.run_metrics or str for `run_metrics`

:param run_metrics: py_interop_run_metrics.run_metrics or str file path to a run folder
:param dtype: data type for the array (Default: 'f4')
:param extra: all extra parameters are passed to `read` if the first parameter is a str file path to a run folder
:return: structured with column names and dype - np.array
</pre> 
</div>
</div>
<a class="anchor" id="adf94f477c2741f95442069950614ac76"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def core.imaging_columns </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>run_metrics</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>extra</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Get a list of imaging table columns

&gt;&gt;&gt; from interop import imaging_columns
&gt;&gt;&gt; from interop import load_imaging_metrics
&gt;&gt;&gt; import interop.py_interop_run_metrics as interop_metrics
&gt;&gt;&gt; import numpy as np
&gt;&gt;&gt; ar = imaging_columns("some/path/run_folder_name") # doctest: +SKIP

The above function is equivalent to
&gt;&gt;&gt; ar = imaging_columns("some/path/run_folder_name", valid_to_load=load_imaging_metrics()) # doctest: +SKIP

We can select a subset of metrics to include based on metric groups
&gt;&gt;&gt; ar = imaging_columns("some/path/run_folder_name", valid_to_load=['Error']) # doctest: +SKIP

See `read` below for more examples.

The following example will rely on an existing run_metrics object (possibly created by the `read` function below).

&gt;&gt;&gt; imaging_columns(run_metrics_example)
['Lane', 'Tile', 'Cycle', 'Read', 'Cycle Within Read', 'Error Rate', 'P90/green', 'P90/blue', '% No Calls', '% Base/A', '% Base/C', '% Base/G', '% Base/T', 'Fwhm/green', 'Fwhm/blue', 'Corrected/A', 'Corrected/C', 'Corrected/G', 'Corrected/T', 'Called/A', 'Called/C', 'Called/G', 'Called/T', 'Signal To Noise', 'Surface', 'Swath', 'Tile Number']

:param run_metrics: py_interop_run_metrics.run_metrics or str file path to a run folder
:param extra: all extra parameters are passed to `read` if the first parameter is a str file path to a run folder
:return: list of string headers
</pre> 
</div>
</div>
<a class="anchor" id="aa2d77c36f24e55d0d9f31de38e9cb55e"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def core.index_summary </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>run_metrics</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>level</em> = <code>'Lane'</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>columns</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>dtype</em> = <code>'f4'</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>extra</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Index summary table

&gt;&gt;&gt; from interop import index_summary
&gt;&gt;&gt; ar = index_summary("some/path/run_folder_name") # doctest: +SKIP

&gt;&gt;&gt; index_summary(run_metrics_with_indexing)
array([(1, 0.4556, 1015.5555, 520.6667, 1536.2222, 1800., 2000.)],
      dtype=[('Lane', '&lt;u2'), ('Mapped Reads Cv', '&lt;f4'), ('Max Mapped Reads', '&lt;f4'), ('Min Mapped Reads', '&lt;f4'), ('Total Fraction Mapped Reads', '&lt;f4'), ('Total Pf Reads', '&lt;f4'), ('Total Reads', '&lt;f4')])

&gt;&gt;&gt; index_summary(run_metrics_with_indexing, level='Barcode')
array([(1, 18280., 1015.5555, 1., 'ATCACGAC', 'AAGGTTCA', 'TSCAIndexes', '1'),
       (1,  9372.,  520.6667, 2., 'ATCACGAC', 'GGGGGGGG', 'TSCAIndexes', '2')],
      dtype=[('Lane', '&lt;u2'), ('Cluster Count', '&lt;f4'), ('Fraction Mapped', '&lt;f4'), ('Id', '&lt;f4'), ('Index1', 'O'), ('Index2', 'O'), ('Project Name', 'O'), ('Sample Id', 'O')])

&gt;&gt;&gt; index_summary(run_metrics_with_indexing, columns=['Total Fraction Mapped Reads'])
array([(1, 1536.2222)],
      dtype=[('Lane', '&lt;u2'), ('Total Fraction Mapped Reads', '&lt;f4')])

&gt;&gt;&gt; index_summary(run_metrics_with_indexing, columns=['Incorrect'])
Traceback (most recent call last):
...
ValueError: Column `Incorrect` not found in: ['Mapped Reads Cv', 'Max Mapped Reads', 'Min Mapped Reads', 'Total Fraction Mapped Reads', 'Total Pf Reads', 'Total Reads'] - column not consistent with level or misspelled

&gt;&gt;&gt; index_summary(run_metrics_with_indexing, level='Incorrect')
Traceback (most recent call last):
...
ValueError: level=Incorrect not in ('Lane', 'Barcode')

:param run_metrics: py_interop_run_metrics.run_metrics or string run folder path
:param level: level of the data to summarize, valid values include: 'Total', 'NonIndex', 'Read', 'Lane', 'Surface' (Default: Total)
:param columns: list of columns (valid values depend on the level) see `summary_columns`
:param dtype: data type for the array (Default: 'f4')
:param extra: all extra parameters are passed to `read` if the first parameter is a str file path to a run folder
:return: structured with column names and dype - np.array
</pre> 
</div>
</div>
<a class="anchor" id="a0491c7a5e13b732447a6ba17fb6150b2"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def core.index_summary_columns </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>level</em> = <code>'Lane'</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>ret_dict</em> = <code>False</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">List the columns of the `index_summary` table

&gt;&gt;&gt; from interop import index_summary_columns
&gt;&gt;&gt; index_summary_columns()
('Mapped Reads Cv', 'Max Mapped Reads', 'Min Mapped Reads', 'Total Fraction Mapped Reads', 'Total Pf Reads', 'Total Reads')


&gt;&gt;&gt; index_summary_columns('Barcode')
('Cluster Count', 'Fraction Mapped', 'Id', 'Index1', 'Index2', 'Project Name', 'Sample Id')

:param level: level of the data to summarize, valid values include: 'Lane', 'Barcode' (Default: Lane)
:param ret_dict: if true, return a dict mapping from column name to method name (Default: False)
:return: tuple of columns (or dictionary mapping column name to method depending on `ret_dict` parameter)
</pre> 
</div>
</div>
<a class="anchor" id="ab2c33eaddb2b6296a8a175cf70316324"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def core.indexing </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>run_metrics</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>per_sample</em> = <code>True</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>dtype</em> = <code>'f4'</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>stype</em> = <code>'O'</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>extra</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Convert InterOp run_metrics (or read run_metrics from disk) to a numpy structured array containing an
indexing table

We can read an indexing table directly from a run folder. Note, this does not load all metrics, only those required
by the indexing table, e.g. IndexMetricsOut.bin

&gt;&gt;&gt; from interop import indexing
&gt;&gt;&gt; ar = indexing("some/path/run_folder_name") # doctest: +SKIP

Note that `valid_to_load` in `read` is ignored.


We can also convert a `run_metrics` object to an indexing table as follows
&gt;&gt;&gt; ar = indexing(run_metrics_with_indexing)
&gt;&gt;&gt; ar
array([(1., 1101., 'ATCACGAC-AAGGTTCA', '1', 4570., 900., 507.77777),
       (1., 1101., 'ATCACGAC-GGGGGGGG', '2', 2343., 900., 260.33334),
       (1., 1102., 'ATCACGAC-AAGGTTCA', '1', 4570.,   0.,   0.     ),
       (1., 1102., 'ATCACGAC-GGGGGGGG', '2', 2343.,   0.,   0.     )],
      dtype=[('Lane', '&lt;f4'), ('Tile', '&lt;f4'), ('Barcode', 'O'), ('SampleID', 'O'), ('Cluster Count', '&lt;f4'), ('Cluster Count PF', '&lt;f4'), ('% Demux', '&lt;f4')])

The `indexing` function also provides an overall sample view by setting `per_sample=False`.

&gt;&gt;&gt; ar = indexing(run_metrics_with_indexing, per_sample=False)
&gt;&gt;&gt; ar
array([(1., 1101., 1000., 900., 768.11115),
       (1., 1102.,    0.,   0.,   0.     )],
      dtype=[('Lane', '&lt;f4'), ('Tile', '&lt;f4'), ('Cluster Count', '&lt;f4'), ('Cluster Count PF', '&lt;f4'), ('% Demux', '&lt;f4')])

:param run_metrics: py_interop_run_metrics.run_metrics or string run folder path
:param per_sample: return demux per sample (Default: True)
:param dtype: data type for the array (Default: 'f4')
:param stype: string type for the array (Default: 'O')
:param extra: all extra parameters are passed to `read` if the first parameter is a str file path to a run folder
:return: structured with column names and dype - np.array
</pre> 
</div>
</div>
<a class="anchor" id="a4637a8261f8dbd40cf86dacfe13499c6"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def core.load_imaging_metrics </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">List of valid imaging metrics to load

&gt;&gt;&gt; from interop import load_to_string_list
&gt;&gt;&gt; from interop import load_imaging_metrics
&gt;&gt;&gt; load_to_string_list(load_imaging_metrics())
['CorrectedInt', 'Error', 'Extraction', 'Image', 'Q', 'Tile', 'QByLane', 'QCollapsed', 'EmpiricalPhasing', 'DynamicPhasing', 'ExtendedTile']

:return: valid_to_load
</pre> 
</div>
</div>
<a class="anchor" id="a596ca1683cb46d9ec6759c95c3dd5ccc"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def core.load_summary_metrics </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">List of valid summary metrics to load

&gt;&gt;&gt; from interop import load_to_string_list
&gt;&gt;&gt; from interop import load_summary_metrics
&gt;&gt;&gt; load_to_string_list(load_summary_metrics())
['CorrectedInt', 'Error', 'Extraction', 'Q', 'Tile', 'QByLane', 'QCollapsed', 'EmpiricalPhasing', 'ExtendedTile']

:return: valid_to_load
</pre> 
</div>
</div>
<a class="anchor" id="a99bcd29dfabd7b48ed2b4fce7740bd05"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def core.load_to_string_list </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>valid_to_load</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Create a string list of names for each enabled metric in `valid_to_load`

&gt;&gt;&gt; from interop import create_valid_to_load, load_to_string_list
&gt;&gt;&gt; import interop.py_interop_run as interop_run
&gt;&gt;&gt; valid_to_load = create_valid_to_load('Extraction')
&gt;&gt;&gt; load_to_string_list(valid_to_load)
['Extraction']
&gt;&gt;&gt; valid_to_load = interop_run.uchar_vector(interop_run.MetricCount, 1)
&gt;&gt;&gt; load_to_string_list(valid_to_load)
['CorrectedInt', 'Error', 'Extraction', 'Image', 'Index', 'Q', 'Tile', 'QByLane', 'QCollapsed', 'EmpiricalPhasing', 'DynamicPhasing', 'ExtendedTile', 'SummaryRun']

:param valid_to_load: boolean buffer
:return: list of strings containing the name of each metric enabled in `valid_to_load`
</pre> 
</div>
</div>
<a class="anchor" id="ac87c7fef8f2bf170c4e08f70cfce2787"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def core.read </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>run</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>valid_to_load</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>requires</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>search_paths</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>extra</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Read InterOp metrics into a run_metrics object

- List of validate valid_to_load names can be gotten using `list_interop_files`
- If run is `interop.py_interop_run_metrics.run_metrics` then run is returned.
- If an InterOp file is missing from the `requires` list, then an empty run_metrics object is returned

Read in all metrics from a run folder
&gt;&gt;&gt; from interop import read
&gt;&gt;&gt; metrics = read("some/path/run_folder_name") # doctest: +SKIP

Read in only ErrorMetricsOut.bin in a run folder
&gt;&gt;&gt; metrics = read("some/path/run_folder_name", valid_to_load=['Error']) # doctest: +SKIP

Read in ErrorMetricsOut.bin and ExtractionMetricsOut.bin but if ErrorMetricsOut.bin is missing return an empty
&gt;&gt;&gt; metrics = read("some/path/run_folder_name", valid_to_load=['Error', 'Extraction'], requires=['Error']) # doctest: +SKIP

Read in IndexMetricsOut.bin and search for it outside the run folder in `fastq/reports`
&gt;&gt;&gt; metrics = read("some/path/run_folder_name", valid_to_load=['Index'], search_paths=['fastq/reports']) # doctest: +SKIP

Read in a run folder that is not found
&gt;&gt;&gt; metrics = read("some/non/existing/run_folder_name")
Traceback (most recent call last):
...
interop.py_interop_run.xml_file_not_found_exception: cannot open file some/non/existing/run_folder_name/RunInfo.xml

Read from a None object
&gt;&gt;&gt; metrics = read(None)
Traceback (most recent call last):
...
ValueError: invalid null reference in method 'run_metrics_read', argument 2 of type 'std::string const &amp;'

:param run: string path including name of run folder (or run_metrics object)
:param valid_to_load: list of strings containing InterOp metric names (Default: None, load everything)
:param requires: list of required metric (Default: None, check nothing)
:param search_paths: list of paths to search when looking for `IndexMetricsOut.bin` (Default: None, do not search)
:return: interop.py_interop_run_metrics.run_metrics
</pre> 
</div>
</div>
<a class="anchor" id="a4f27776530b4094e088007839a2ca548"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def core.read_metric </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>filename</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>run_metrics</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>finalize</em> = <code>False</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Read a specific metric from a file into a run_metrics object

This function allows incremental reading of metric files from disk. The last call should set
`finalize=True`.

Read in `ErrorMetricsOut.bin` into a run_metrics object and finalize since this is the only metric we plan to read

&gt;&gt;&gt; from interop import read_metric
&gt;&gt;&gt; metrics = read_metric("some/path/run_folder_name/InterOp/ErrorMetricsOut.bin", finalize=True) # doctest: +SKIP

:param filename: path to InterOp file
:param run_metrics: existing run_metrics object (Default None, one will be created)
:param finalize: if true, then call finalize_after_load (last call to `read_metric` should set finalize=True)
:return: interop.py_interop_run_metrics.run_metrics
</pre> 
</div>
</div>
<a class="anchor" id="a7299ac8ed2d54e8738cbd72c3fc6b3e8"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def core.summary </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>run_metrics</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>level</em> = <code>'Total'</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>columns</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>dtype</em> = <code>'f4'</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>ignore_missing_columns</em> = <code>True</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>extra</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Generate a summary table with the given level, columns and dtype from a run_metrics object or run_folder path

Note that not all columns will be included if InterOp files are missing or purposing excluded using `valid_to_load`.

The following examples show the different levels that one can summarize the data including:

 - Total (Default)
 - NonIndex
 - Read
 - Lane
 - Summary

&gt;&gt;&gt; from interop import summary
&gt;&gt;&gt; ar = summary("some/path/run_folder_name") # doctest: +SKIP
&gt;&gt;&gt; ar = summary("some/path/run_folder_name", valid_to_load=['Error']) # doctest: +SKIP


&gt;&gt;&gt; summary(run_metrics_example)
array([(0.36666667, 6.6666665, 0., 0., 0.)],
      dtype=[('Error Rate', '&lt;f4'), ('First Cycle Intensity', '&lt;f4'), ('Projected Yield G', '&lt;f4'), ('Reads', '&lt;f4'), ('Reads Pf', '&lt;f4')])

&gt;&gt;&gt; summary(run_metrics_example, 'Total')
array([(0.36666667, 6.6666665, 0., 0., 0.)],
      dtype=[('Error Rate', '&lt;f4'), ('First Cycle Intensity', '&lt;f4'), ('Projected Yield G', '&lt;f4'), ('Reads', '&lt;f4'), ('Reads Pf', '&lt;f4')])

&gt;&gt;&gt; summary(run_metrics_example, 'NonIndex')
array([(0.2, 10., 0., 0., 0.)],
      dtype=[('Error Rate', '&lt;f4'), ('First Cycle Intensity', '&lt;f4'), ('Projected Yield G', '&lt;f4'), ('Reads', '&lt;f4'), ('Reads Pf', '&lt;f4')])

&gt;&gt;&gt; summary(run_metrics_example, 'Read')
array([(1, 78, 0.2, 10., 0., 0., 0.), (2, 89, 0.4,  5., 0., 0., 0.),
       (3, 89, 0.5,  5., 0., 0., 0.)],
      dtype=[('ReadNumber', '&lt;u2'), ('IsIndex', 'u1'), ('Error Rate', '&lt;f4'), ('First Cycle Intensity', '&lt;f4'), ('Projected Yield G', '&lt;f4'), ('Reads', '&lt;f4'), ('Reads Pf', '&lt;f4')])

&gt;&gt;&gt; summary(run_metrics_example, 'Lane')
array([(1, 78, 1, 0.2, 10., 0., 0., 0., 1.),
       (2, 89, 1, 0.4,  5., 0., 0., 0., 1.),
       (3, 89, 1, 0.5,  5., 0., 0., 0., 1.)],
      dtype=[('ReadNumber', '&lt;u2'), ('IsIndex', 'u1'), ('Lane', '&lt;u2'), ('Error Rate', '&lt;f4'), ('First Cycle Intensity', '&lt;f4'), ('Projected Yield G', '&lt;f4'), ('Reads', '&lt;f4'), ('Reads Pf', '&lt;f4'), ('Tile Count', '&lt;f4')])

For a single surface, as is this example, nothing is reported.
&gt;&gt;&gt; summary(run_metrics_example, 'Surface')
array([], dtype=float64)

We can select specific columns using the `columns` parameter
&gt;&gt;&gt; summary(run_metrics_example, 'Total', columns=['First Cycle Intensity', 'Error Rate'])
array([(6.6666665, 0.36666667)],
      dtype=[('First Cycle Intensity', '&lt;f4'), ('Error Rate', '&lt;f4')])

If a column values are NaN, or missing, then it will automatically be excluded
&gt;&gt;&gt; summary(run_metrics_example, 'Total', columns=['% Aligned', 'Error Rate'])
array([(0.36666667,)], dtype=[('Error Rate', '&lt;f4')])

To include missing columns, set `ignore_missing_columns=False`
&gt;&gt;&gt; summary(run_metrics_example, 'Total', ignore_missing_columns=False, columns=['% Aligned', 'Error Rate'])
array([(nan, 0.36666667)],
      dtype=[('% Aligned', '&lt;f4'), ('Error Rate', '&lt;f4')])

&gt;&gt;&gt; summary(run_metrics_example, 'Total', columns=['Incorrect'])
Traceback (most recent call last):
 ...
ValueError: Column `Incorrect` not found in: ['Error Rate', 'First Cycle Intensity', '% Aligned', '% &gt;= Q30', '% Occupancy Proxy', '% Occupied', 'Projected Yield G', 'Yield G'] - column not consistent with level or misspelled


:param run_metrics: py_interop_run_metrics.run_metrics or string run folder path
:param level: level of the data to summarize, valid values include: 'Total', 'NonIndex', 'Read', 'Lane', 'Surface' (Default: Total)
:param columns: list of columns (valid values depend on the level) see `summary_columns`
:param dtype: data type for the array (Default: 'f4')
:param ignore_missing_columns: ignore missing columns, e.g. those with NaN values (Default: True)
:param extra: all extra parameters are passed to `read` if the first parameter is a str file path to a run folder
:return: structured with column names and dype - np.array
</pre> 
</div>
</div>
<a class="anchor" id="a56bf215828f129b8251ddfcb17b6612a"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def core.summary_columns </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>level</em> = <code>'Total'</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>ret_dict</em> = <code>False</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Get a list of column names supported at each level of the summary table

&gt;&gt;&gt; from interop import summary_columns

The default columns are for the Run/Read level
&gt;&gt;&gt; summary_columns()
('Cluster Count', 'Cluster Count Pf', 'Error Rate', 'First Cycle Intensity', '% Aligned', '% &gt;= Q30', '% Occupancy Proxy', '% Occupied', 'Projected Yield G', 'Reads', 'Reads Pf', 'Yield G')
&gt;&gt;&gt; summary_columns(level='Total')
('Cluster Count', 'Cluster Count Pf', 'Error Rate', 'First Cycle Intensity', '% Aligned', '% &gt;= Q30', '% Occupancy Proxy', '% Occupied', 'Projected Yield G', 'Reads', 'Reads Pf', 'Yield G')
&gt;&gt;&gt; summary_columns(level='NonIndex')
('Cluster Count', 'Cluster Count Pf', 'Error Rate', 'First Cycle Intensity', '% Aligned', '% &gt;= Q30', '% Occupancy Proxy', '% Occupied', 'Projected Yield G', 'Reads', 'Reads Pf', 'Yield G')
&gt;&gt;&gt; summary_columns(level='Read')
('Cluster Count', 'Cluster Count Pf', 'Error Rate', 'First Cycle Intensity', '% Aligned', '% &gt;= Q30', '% Occupancy Proxy', '% Occupied', 'Projected Yield G', 'Reads', 'Reads Pf', 'Yield G')

The lane/surface level give another set of columns for the summary table
&gt;&gt;&gt; summary_columns(level='Lane')
('Cluster Count', 'Cluster Count Pf', 'Density', 'Density Pf', 'Error Rate', 'Error Rate 100', 'Error Rate 35', 'Error Rate 50', 'Error Rate 75', 'First Cycle Intensity', '% Aligned', '% &gt;= Q30', '% Occupied', '% Pf', 'Phasing', 'Phasing Offset', 'Phasing Slope', 'Prephasing', 'Prephasing Offset', 'Prephasing Slope', 'Projected Yield G', 'Reads', 'Reads Pf', 'Tile Count', 'Yield G')
&gt;&gt;&gt; summary_columns(level='Surface')
('Cluster Count', 'Cluster Count Pf', 'Density', 'Density Pf', 'Error Rate', 'Error Rate 100', 'Error Rate 35', 'Error Rate 50', 'Error Rate 75', 'First Cycle Intensity', '% Aligned', '% &gt;= Q30', '% Occupied', '% Pf', 'Phasing', 'Phasing Offset', 'Phasing Slope', 'Prephasing', 'Prephasing Offset', 'Prephasing Slope', 'Projected Yield G', 'Reads', 'Reads Pf', 'Tile Count', 'Yield G')

:param level: level of the data to summarize, valid values include: 'Run', 'Read', 'Lane', 'Surface' (Default: Run)
:param ret_dict: if true, return a dict mapping from column name to method name (Default: False)
:return: tuple of columns - each column is a tuple, or a tuple of lambda functions that take the run_info as an argument
</pre> 
</div>
</div>
<h2 class="groupheader">Variable Documentation</h2>
<a class="anchor" id="a4135f6454013242755ca4f40b0154e36"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">tuple _index_summary_levels = ('Lane', 'Barcode')</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="a38d15b47e551e4a1748077708683f034"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">tuple _summary_levels = ('Total', 'NonIndex', 'Read', 'Lane', 'Surface')</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
</div><!-- contents -->
<!-- HTML footer for doxygen 1.8.10-->
<!-- start footer part -->
<hr class="footer"/>
</body>
</html>
